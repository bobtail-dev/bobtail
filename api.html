<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="styles/9981d504.main.css" media="screen">
    <title>API Reference - bobtail</title>
  </head>
  <body>
    <header>
      <div class="overlay"></div>
      <div class="inner">
        <h1 class="smaller-title"><a href="/reactive-coffee/">bobtail</a></h1>
        <nav class="top-nav">
          <div class="inner-inner"><a href="quickstart.html">Documentation</a><a href="support.html">Community/Support</a><a href="design.html">Rationale</a><a href="dev-setup.html">Development</a></div>
        </nav>
      </div>
    </header>
    <div id="content-wrapper">
      <div class="inner clearfix">
        <nav class="side-nav">
          <ul>
            <li><a href="quickstart.html">Quickstart Examples</a></li>
            <li><a href="tutorial.html">Tutorial</a></li>
            <li><a href="advanced.html">Advanced Concepts</a></li>
            <li><a href="api.html" class="current">API Reference</a><ul class="toc"><li><a href="#rx-namespace"><code>rx</code> Namespace</a></li><li><a href="#rx-rxt-namespace"><code>rx.rxt</code> Namespace</a></li></ul></li>
            <li><a href="changes.html">Change Log</a></li>
          </ul>
        </nav>
        <section id="main-content"><h1 id="api-reference">API Reference</h1>
<h2 id="-rx-namespace"><a name="rx-namespace"><code>rx</code> Namespace</a></h2>
<p>This contains the core reactive programming primitives.  These are the core
data structures:</p>
<ul>
<li><code>ObsCell</code>: observable cell base class<ul>
<li><code>SrcCell</code>: a source cell, one that can be directly mutated</li>
<li><code>DepCell</code>: a dependent cell, one whose value is some function of another
observable cell</li>
</ul>
</li>
<li><code>ObsArray</code>: observable array base class<ul>
<li><code>SrcArray</code>: a source array, one that can be directly mutated</li>
<li><code>DepArray</code>: a dependent array, one whose value is some transformation of
another observable array</li>
</ul>
</li>
<li><code>ObsMap</code>: observable object (map) base class<ul>
<li><code>SrcMap</code>: a source object, one that can be directly mutated</li>
<li><code>DepMap</code>: a dependent object, one whose value is some transformation of
another observable object</li>
</ul>
</li>
<li><code>Ev</code>: an event node; serves as a pub-sub node for events of a certain
type</li>
</ul>
<p><strong>Free functions</strong></p>
<ul>
<li><code>cell(value)</code>: return a <code>SrcCell</code> initialized to the given value (optional;
defaults to <code>undefined</code>)</li>
<li><code>array(value[, diff])</code>: return a <code>SrcArray</code> initialized to the given
array (optional; defaults to <code>[]</code>) and the given <code>diff</code> function for
computing/propagating the minimal set of change events (defaults to
<code>rx.basicDiff()</code>).</li>
<li><code>bind(fn)</code>: given a 0-ary function, return a <code>DepCell</code> whose value is
bound to the result of evaluating that function.  The function is immediately
evaluated once, and each time it&#39;s evaluated, for any accesses of
observables, the <code>DepCell</code> subscribes to the corresponding events, which may
subsequently trigger future re-evaluations.</li>
<li><code>snap(fn)</code>: evaluate the given 0-ary function while insulating it from
the enclosing bind.  This will be evaluated <em>just once</em> and prevents
subscriptions to any observables contained therein.</li>
<li><code>asyncBind(init, fn)</code>: create an asynchronous bind.  The given <code>fn</code> is
expected to call <code>this.record(f)</code> up to at most one time at some point
during its potentially asynchronous duration before calling
<code>this.done(result)</code>.  The call to <code>this.record(f)</code> evaluates <code>f</code> while
recording the implicit subscriptions triggered by accesses to
observables.  (You can call <code>done</code> from within <code>record</code> but the result
won&#39;t be set on this cell until after <code>record</code> finishes.)  The cell&#39;s
initial value is <code>init</code>.</li>
<li><code>lagBind(lag, init, fn)</code>: same as <code>bind</code> but waits a 500ms delay after
a dependency changes (or after initialization) before the <code>DepCell</code>
refreshes.  For the first 500ms, the cell&#39;s value is <code>init</code>; you can set
this to e.g. <code>noSub(fn)</code> if you want to immediately populate it with the
result of evaluating your given <code>fn</code>.</li>
<li><code>postLagBind(init, fn)</code>: immediately evaluates <code>fn</code>, which is expected to
return a <code>{val, ms}</code>, where <code>ms</code> indicates how long to wait before
publishing <code>val</code> as the new value of this <code>DepCell</code>.  Until the first
published value, the cell is initialized to <code>init</code>.</li>
<li><code>reactify(obj, spec)</code>: mutates an object to replace the specified fields
with ES5 getters/setters powered by an observable cell/array, and
returns the object.  <code>spec</code> is a mapping from field name to <code>{type,
val}</code>, where <code>type</code> is <code>&#39;array&#39;</code> or <code>&#39;cell&#39;</code> and <code>val</code> is an optional
initial value.</li>
<li><code>autoReactify(obj)</code>: mutates an object to <code>reactify</code> all fields
(specifying <code>array</code> for arrays and <code>cell</code> for everything else), and
returns the object</li>
<li><code>flatten(xs)</code>: given an array of either arrays, observable arrays,
observable cells, or other elements, flatten them into one dependent
array, which will be able to react to changes in any of the observables.
It furthermore strips out <code>undefined</code>/<code>null</code> elements (for convenient
conditionals in the array).  This operation is a &quot;deep flatten&quot;---it will
recursively flatten nested arrays.  This function is a useful tool for
building up the DOM---for specifying the children of an element where the
children can consist of many different individual elements, arrays,
and/or conditionals.</li>
<li><code>onDispose(callback)</code>: add a (0-ary) cleanup listener, which gets fired
whenever the current (enclosing) bind is removed or refreshed.  This is
useful for proper resource disposal, such as closing a connection or
removing an interval timer.</li>
<li><code>skipFirst(f)</code>: wrap a 1-ary function such that the first invocation is
simply dropped.  This is useful for subscribing an event listener but
suppressing the initial invocation at subscription time.</li>
<li><code>autoSub(ev, listener)</code>: Subscribes a listener to an event but such that
if this is called from within a <code>bind</code> context, the listener will be
properly cleaned up (unsubscribed) on context disposal.  Returns the
subscription ID.</li>
<li><code>concat(arrays...)</code>: returns a dependent array that is the result of
concatenating multiple <code>ObsArray</code>s (efficiently maintained).</li>
<li><code>cellToArray(cell[, diff])</code>: given an <code>ObsCell</code> of an array, return a
<code>DepArray</code> that issues the minimal set of change events by diffing the
contents of the array to determine what has changed.  Similar in
mechanism to <code>SrcArray.update</code>.  <code>diff</code> is an optional diff function (see
<code>SrcArray.update</code> documentation) and defaults to <code>rx.basicDiff()</code>.</li>
<li><code>cellToMap(cell)</code>: given an <code>ObsCell</code> of a primitive JS object, return a
<code>DepMap</code> that, in response to future new values of the
object, issues the minimal set of events by diffing the contents of the
object to determine what has changed.</li>
<li><code>basicDiff([key])</code>: returns a diff function that takes two arrays and
uses the given key function, which defaults to <code>rx.smartUidify</code>, to
efficiently hash-compare elements between the two arrays.  Used by
<code>rx.cellToArray</code>.</li>
<li><code>smartUidify(x)</code>: returns a unique identifier for the given object.  If
the item is a scalar, then return its JSON string.  If the item is an
object/array/etc., create a unique ID for it, insert it (this is a
standard &quot;hashing hack&quot; for JS) as a non-enumerable property <code>__rxUid</code>,
and return it (or just return any already-existing <code>__rxUid</code>).  I.e.,
this implements reference equality.  Used by <code>rx.basicDiff</code>.</li>
<li><code>lift(x[, spec])</code>: convert an object <code>x</code> containing regular
non-observable fields to one with observable fields instead.  <code>spec</code> is a
mapping from field name to either <code>&#39;cell&#39;</code>, <code>&#39;array&#39;</code>, or <code>&#39;map&#39;</code>, based
on what kind of observable data structure we want.  By default this is
supplied by <code>rx.liftSpec</code>.</li>
<li><code>liftSpec(x)</code>: given an object <code>x</code>, return a spec for <code>rx.lift</code> where any
field that is an array is to be stored in an <code>rx.array</code>, and otherwise in
an <code>rx.cell</code>.</li>
<li><code>transaction(f)</code>: run the given function in a <em>transaction</em>, during which
updates to observables will not emit change events to their subscribers.
Only once the transaction ends will all events be fired (at which time the
state of the source cells will no longer be in flux, and thus a
consistent view of the universe can always be maintained).</li>
<li><code>hideMutationWarnings(f)</code>: Run the given function, but suppress console logging
  of mutation warnings and firing of the <code>onMutationWarnings</code> event. This is useful when
  need to mutate a cell when already within a bind context, but you know that doing so is safe.</li>
</ul>
<p><strong><code>ObsCell</code> members</strong></p>
<ul>
<li><code>get()</code>: return current value of the cell</li>
<li><code>onSet</code>: the event that is fired after the value of the cell is
changed.  The event data is an array of two elements, <code>[oldVal, newVal]</code>.</li>
</ul>
<p><strong><code>SrcCell</code> members</strong></p>
<ul>
<li><code>set(x)</code>: set value of cell to <code>x</code> and return old value of <code>x</code></li>
<li>inherits <code>ObsCell</code></li>
</ul>
<p><strong><code>DepCell</code> members</strong></p>
<ul>
<li>inherits <code>ObsCell</code></li>
<li><code>disconnect</code>: unsubscribes this cell from its dependencies and
recursively disconnects all nested binds; useful for manual disposal of
<code>bind</code>s</li>
</ul>
<p><strong><code>ObsArray</code> members</strong></p>
<ul>
<li><code>at(i)</code>: return element at <code>i</code></li>
<li><code>all()</code>: return array copy of all elements</li>
<li><code>raw()</code>: return raw array of all elements; this is unsafe since mutations
will violate the encapsulated invariants, but serves as a performance
escape hatch around <code>all()</code></li>
<li><code>length()</code>: return size of the array</li>
<li><code>map(fn)</code>: return <code>DepArray</code> of given function mapped over this array</li>
<li><code>onChange</code>: the event that is fired after any part of the array is
changed.  The event data is an array of three elements: <code>[index, added,
removed]</code>, where <code>index</code> is the index where the change occurred, <code>added</code>
is the sub-array of elements that were added, and <code>removed</code> is the
sub-array of elements that were removed.</li>
<li><code>indexed()</code>: return a <code>DepArray</code> that mirrors this array, but whose <code>map</code>
method passes in the index as well.  The mapper function takes <code>(x,i)</code>
where <code>x</code> is the current element and <code>i</code> is a cell whose value always
reflects the index of the current element.</li>
</ul>
<p><strong><code>SrcArray</code> members</strong></p>
<ul>
<li><code>SrcArray([xs[, diff]])</code>: constructor that initializes the content array
to <code>xs</code> (note: keeps a reference and does not create a copy) and the diff
function for <code>update</code> to <code>diff</code> (defaults to <code>rx.basicDiff()</code>).</li>
<li><code>splice(index, count, additions...)</code>: replace <code>count</code> elements starting at
<code>index</code> with <code>additions</code></li>
<li><code>insert(x, i)</code>: insert value <code>x</code> at index <code>i</code></li>
<li><code>remove(x)</code>: find and remove first occurrence of <code>x</code></li>
<li><code>removeAt(i)</code>: remove element at index <code>i</code></li>
<li><code>push(x)</code>: append <code>x</code> to the end of the array</li>
<li><code>put(i, x)</code>: replace element <code>i</code> with value <code>x</code></li>
<li><code>replace(xs)</code>: replace entire array with raw array <code>xs</code></li>
<li><code>update(xs[, diff])</code>: replace entire array with raw array <code>xs</code>, but apply
the <code>diff</code> algorithm to determine the minimal set of changes for which to
emit events.  This enables flexible updating of the array, representing
arbtirary transformations, while at the same time minimizing the
downstream recomputation necessary (particularly DOM manipulations).</li>
<li>inherits <code>ObsArray</code></li>
</ul>
<p><strong><code>DepArray</code> members</strong></p>
<ul>
<li>inherits <code>ObsArray</code></li>
</ul>
<p><strong><code>ObsMap</code> members</strong></p>
<ul>
<li><code>get(k)</code>: return value associated with key <code>k</code></li>
<li><code>all()</code>: return raw object copy</li>
<li><code>onAdd</code>: the event that is fired after an element is added.  The event
data is a map of added keys to their corresponding values.</li>
<li><code>onRemove</code>: the event that is fired after an element is removed.  The
event data is a map of removed keys to their original values.</li>
<li><code>onChange</code>: the event that is fired after a key&#39;s value is changed.  The
event data is a map of changed keys to a two-element list of <code>[old value,
new value]</code>.</li>
</ul>
<p><strong><code>SrcMap</code> members</strong></p>
<ul>
<li><code>put(k, v)</code>: associate value <code>v</code> with key <code>k</code> and return any prior value associated with <code>k</code></li>
<li><code>remove(k)</code>: remove the entry associated at key <code>k</code></li>
<li><code>update(map)</code>: update the current <code>SrcMap</code>&#39;s contents to those of the
given JS object <code>map</code>, triggering any necessary <code>remove</code>s and <code>put</code>s</li>
<li>inherits <code>ObsMap</code></li>
</ul>
<p><strong><code>DepMap</code> members</strong></p>
<ul>
<li>inherits <code>ObsMap</code></li>
</ul>
<p><strong><code>Ev</code> members</strong></p>
<ul>
<li><code>sub(listener)</code>: subscribes a listener function for events from this
event node and returns a unique ID for this subscription, which can be used
as the handle by which to unsubscribe later.  The listener takes a single
argument, whose type depends on the event, and is called every time an
event is fired on this event node.</li>
<li><code>pub(data)</code>: publish an event, described by the data in <code>data</code>.  <code>data</code>
is what will be passed to all the subscribed listeners.</li>
<li><code>unsub(subscriptionId)</code>: detaches a listener from this event.</li>
</ul>
<h2 id="-rx-rxt-namespace"><a name="rx-rxt-namespace"><code>rx.rxt</code> Namespace</a></h2>
<p>This contains the template DSL constructs.  Main thing here is the <em>tag
function</em>, which is what constructs a DOM element.</p>
<p><strong>Free functions</strong></p>
<ul>
<li><code>mktag(tag)</code>: returns a tag function of the given tag name.  The various
tags like <code>div</code> and <code>h2</code> are simply aliases; e.g., <code>div = mktag(&#39;div&#39;)</code>.
Tag functions themselves take <code>(attrs, contents)</code>, both optional, where
<code>attrs</code> is a JavaScript object of HTML attributes and/or <em>special
attributes</em> and <code>contents</code> is an array (<code>ObsArray</code> or regular <code>Array</code>) of
child nodes (either raw elements, <code>RawHtml</code>, or jQuery objects) and/or
strings (for text nodes).  You can also pass in a singular such node
without the array.  The function returns an instance of the specified
element wrapped in a jQuery object.  See also <code>specialAttrs</code> below for
more on special attributes.</li>
<li><code>importTags([dest])</code>: populate the global namespace (or the <code>dest</code> object
if given) with the tag symbols, so you don&#39;t need have <code>rxt</code> all over
your templates.  Useful for quickly throwing something together.</li>
<li><code>rawHtml(html)</code>: returns a <code>RawHtml</code> wrapper for strings that tags won&#39;t
escape when rendering; example: <code>div {}, [rawHtml(&#39;&lt;span&gt;hello&lt;/span&gt;&#39;)]</code></li>
<li><code>rxt.cast(...)</code>: two forms:<ul>
<li><code>rxt.cast(opts, types)</code>: convenience utility for use in preparing
arguments for a component.  <code>opts</code> is the arguments object mapping,
and <code>types</code> is an object mapping fields of <code>opts</code> to either <code>cell</code> or
<code>array</code>.  <code>cast</code> returns a copy of <code>opts</code> but with the fields casted
based on the specified desired <code>types</code> (yielding observable cells and
arrays).</li>
<li><code>rxt.cast(data, type)</code>: lift the given datum to the given type; acts
as identity function if data is already of the proper type</li>
</ul>
</li>
<li><code>rxt.cssify(props)</code>: <strong>(deprecated: set the <code>style</code> property directly to
a JSON object instead of using this so as to use <code>jQuery.css</code>, which is
smarter about interpreting the given values)</strong> convenience utility for
programmatically constructing strings suitable for use as a <code>style</code>
attribute.  Takes an object mapping camelCase versions of style property
names and values that are either strings (which are put in verbatim),
numbers (which are written as pixels), or <code>null</code>/<code>undefined</code> (which
omits that property altogether).</li>
<li><code>rxt.smushClasses(classes)</code>: convenience utility for programmatically
constructing strings suitable for use as a <code>class</code> attribute.  Takes an
array of strings or <code>undefined</code>s (useful for conditionally including a
class), and filters out the <code>null</code>/<code>undefined</code>.</li>
<li>Tags: <code>p</code>, <code>br</code>, <code>ul</code>, <code>li</code>, <code>span</code>, <code>anchor</code>, <code>div</code>, <code>input</code>, <code>select</code>,
<code>option</code>, <code>label</code>, <code>button</code>, <code>fieldset</code>, <code>legend</code>, <code>section</code>, <code>header</code>,
<code>footer</code>, <code>strong</code>, <code>h1</code>, <code>h2</code>, <code>h3</code>, <code>h4</code>, <code>h5</code>, <code>h6</code>, <code>h7</code></li>
</ul>
<p><strong>jQuery plug-in</strong></p>
<ul>
<li><code>rx(property)</code>: lazily create (or take the cached instance) of a cell whose
value is maintained to reflect the desired property on the element.
<code>property</code> can be <code>&#39;checked&#39;</code>, <code>&#39;focused&#39;</code>, or <code>&#39;val&#39;</code>.  Returns the cell.</li>
</ul>
<p><strong>Special attributes</strong></p>
<p><em>Special attributes</em> are handled differently from normal.  The built-in
special attributes are primarily events like <code>click</code>:</p>
<div class="highlight"><pre><span class="nx">button</span> <span class="p">{</span><span class="nv">click: </span><span class="nf">-&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s">&#39;hello&#39;</span><span class="p">)},</span> <span class="s">&#39;Hello&#39;</span>
</pre></div>

<p>Special attributes are really just a convenient short-hand for running the
handler functions after constructing object.  The above example is equivalent to:</p>
<div class="highlight"><pre><span class="nv">$button = </span><span class="nx">button</span> <span class="s">&#39;Hello&#39;</span>
<span class="nx">$button</span><span class="p">.</span><span class="nx">click</span> <span class="nf">-&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s">&#39;hello&#39;</span><span class="p">)</span>
</pre></div>

<p>The built-in special attributes available include:</p>
<ul>
<li><p><code>init</code>: which is a 0-ary function that is run immediately upon
instantiation of the element.</p>
</li>
<li><p><code>style</code>: automatically transforms the given value with <code>cssify</code> if it&#39;s
not a string</p>
</li>
<li><p><code>class</code>: automatically transforms the given value with <code>smushClasses</code> if
it&#39;s not a string</p>
</li>
<li><p>events like <code>click</code>, <code>focus</code>, <code>mouseleave</code>, <code>keyup</code>, <code>load</code>, etc.,:
these are available for all jQuery events.  The handlers are similar to
those you would pass to a jQuery event method—they take a jQuery event
and return false to stop propagation—but the context is the
jQuery-wrapped element instead of the raw element.  The full list:</p>
<ul>
<li><code>blur</code></li>
<li><code>change</code></li>
<li><code>click</code></li>
<li><code>dblclick</code></li>
<li><code>error</code></li>
<li><code>focus</code></li>
<li><code>focusin</code></li>
<li><code>focusout</code></li>
<li><code>hover</code></li>
<li><code>keydown</code></li>
<li><code>keypress</code></li>
<li><code>keyup</code></li>
<li><code>load</code></li>
<li><code>mousedown</code></li>
<li><code>mouseenter</code></li>
<li><code>mouseleave</code></li>
<li><code>mousemove</code></li>
<li><code>mouseout</code></li>
<li><code>mouseover</code></li>
<li><code>mouseup</code></li>
<li><code>ready</code></li>
<li><code>resize</code></li>
<li><code>scroll</code></li>
<li><code>select</code></li>
<li><code>submit</code></li>
<li><code>toggle</code></li>
<li><code>unload</code></li>
</ul>
</li>
</ul>
<p><code>specialAttrs</code>: an object mapping special attribute names to the functions
that handle them.  When an element specifies a special attribute, this
handler function is invoked.  The handler function takes <code>(element, value,
attrs, contents)</code>, where:</p>
<ul>
<li><code>element</code> is the element being operated on</li>
<li><code>value</code> is the value of this special attribute for <code>element</code></li>
<li><code>attrs</code> is the full map of attributes for <code>element</code></li>
<li><code>contents</code> is the content/children for <code>element</code> (which can be a
string, <code>RawHtml</code>, array, <code>ObsCell</code>, or <code>ObsArray</code>)</li>
</ul>
<p>So for instance, we can create a special attribute <code>drag</code> that just
forwards to the jQuery <code>[jdragdrop]</code> plug-in:</p>
<div class="highlight"><pre><span class="nv">rxt.specialAttrs.drag = </span><span class="nf">(elt, fn, attrs, contents) -&gt;</span> <span class="nx">elt</span><span class="p">.</span><span class="nx">drag</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
</pre></div>

<p>and then use it like so in your templates:</p>
<div class="highlight"><pre><span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;block&#39;</span><span class="p">,</span> <span class="nv">drag: </span><span class="nf">-&gt;</span> <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">css</span><span class="p">(</span><span class="s">&#39;top&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">offsetY</span><span class="p">)}</span>
</pre></div>


        </section>
      </div>
    </div><!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41900480-1', 'yang.github.io');
      ga('send', 'pageview');
    </script>
    <footer>
      <div class="inner"><p>Copyright 2017 Bobtail/Reactive Coffee Authors.<br>Code licensed under <a href="https://github.com/inferinc/bobtail/blob/master/LICENSE">MIT License</a>.  Documentation licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.<br>Website design based on Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>

      </div>
    </footer>
  </body>
</html>
