<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="styles/9981d504.main.css" media="screen">
    <title>API Reference - reactive.coffee</title>
  </head>
  <body>
    <header>
      <div class="overlay"></div>
      <div class="inner">
        <h1 class="smaller-title"><a href="/reactive-coffee/">reactive.coffee</a></h1>
        <nav class="top-nav">
          <div class="inner-inner"><a href="quickstart.html">Documentation</a><a href="support.html">Community/Support</a><a href="design.html">Rationale</a><a href="dev-setup.html">Development</a></div>
        </nav>
      </div>
    </header>
    <div id="content-wrapper">
      <div class="inner clearfix">
        <nav class="side-nav">
          <ul>
            <li><a href="quickstart.html">Quickstart Examples</a></li>
            <li><a href="tutorial.html">Tutorial</a></li>
            <li><a href="advanced.html">Advanced Concepts</a></li>
            <li><a href="api.html" class="current">API Reference</a><ul class="toc"><li><a href="#rx-namespace"><code>rx</code> Namespace</a></li><li><a href="#rxt-namespace"><code>rxt</code> Namespace</a></li></ul></li>
            <li><a href="changes.html">Change Log</a></li>
          </ul>
        </nav>
        <section id="main-content"><h1>API Reference</h1>
<h2><a name="rx-namespace"><code>rx</code> Namespace</a></h2>
<p>This contains the core reactive programming primitives.  These are the core
data structures:</p>
<ul>
<li><code>ObsCell</code>: observable cell base class<ul>
<li><code>SrcCell</code>: a source cell, one that can be directly mutated</li>
<li><code>DepCell</code>: a dependent cell, one whose value is some function of another
observable cell</li>
</ul>
</li>
<li><code>ObsArray</code>: observable array base class<ul>
<li><code>SrcArray</code>: a source array, one that can be directly mutated</li>
<li><code>DepArray</code>: a dependent array, one whose value is some transformation of
another observable array</li>
</ul>
</li>
<li><code>ObsMap</code>: observable object (map) base class<ul>
<li><code>SrcMap</code>: a source object, one that can be directly mutated</li>
<li><code>DepMap</code>: a dependent object, one whose value is some transformation of
another observable object</li>
</ul>
</li>
<li><code>Ev</code>: an event node; serves as a pub-sub node for events of a certain
type</li>
</ul>
<p><strong>Free functions</strong></p>
<ul>
<li><code>cell(value)</code>: return a <code>SrcCell</code> initialized to the given value (optional;
defaults to <code>undefined</code>)</li>
<li><code>array(value)</code>: return a <code>SrcArray</code> initialized to the given array (optional;
defaults to <code>[]</code>)</li>
<li><code>bind(fn)</code>: given a 0-ary function, return a <code>DepCell</code> whose value is
bound to the result of evaluating that function.  The function is immediately
evaluated once, and each time it&#39;s evaluated, for any accesses of
observables, the <code>DepCell</code> subscribes to the corresponding events, which may
subsequently trigger future re-evaluations.</li>
<li><code>snap(fn)</code>: evaluate the given 0-ary function while insulating it from
the enclosing bind.  This will be evaluated <em>just once</em> and prevents
subscriptions to any observables contained therein.</li>
<li><code>asyncBind(init, fn)</code>: create an asynchronous bind.  The given <code>fn</code> is
expected to call <code>this.record(f)</code> up to at most one time at some point
during its potentially asynchronous duration before calling
<code>this.done(result)</code>.  The call to <code>this.record(f)</code> evaluates <code>f</code> while
recording the implicit subscriptions triggered by accesses to
observables.  The cell&#39;s initial value is <code>init</code>.</li>
<li><code>lagBind(lag, init, fn)</code>: same as <code>bind</code> but waits a 500ms delay after
a dependency changes (or after initialization) before the <code>DepCell</code>
refreshes.  For the first 500ms, the cell&#39;s value is <code>init</code>; you can set
this to e.g. <code>noSub(fn)</code> if you want to immediately populate it with the
result of evaluating your given <code>fn</code>.</li>
<li><code>postLagBind(init, fn)</code>: immediately evaluates <code>fn</code>, which is expected to
return a <code>{val, ms}</code>, where <code>ms</code> indicates how long to wait before
publishing <code>val</code> as the new value of this <code>DepCell</code>.  Until the first
published value, the cell is initialized to <code>init</code>.</li>
<li><code>reactify(obj, spec)</code>: mutates an object to replace the specified fields
with getters/setters powered by an observable cell/array, and returns the
object.  <code>spec</code> is a mapping from field name to <code>{type, val}</code>, where
<code>type</code> is <code>&#39;array&#39;</code> or <code>&#39;cell&#39;</code> and <code>val</code> is an optional initial value.</li>
<li><code>autoReactify(obj)</code>: mutates an object to <code>reactify</code> all fields
(specifying <code>array</code> for arrays and <code>cell</code> for everything else), and
returns the object</li>
<li><code>flatten(xs)</code>: given an array of either arrays, observable arrays,
observable cells, or other elements, flatten them into one dependent
array, which will be able to react to changes in any of the observables.
It furthermore strips out undefined/null elements (for convenient
conditionals in the array).</li>
<li><code>onDispose(callback)</code>: add a (0-ary) cleanup listener, which gets fired
whenever the current (enclosing) bind is removed or refreshed.  This is
useful for proper resource disposal, such as closing a connection or
removing an interval timer.</li>
<li><code>skipFirst(f)</code>: wrap a 1-ary function such that the first invocation is
simply dropped.  This is useful for subscribing an event listener but
suppressing the initial invocation at subscription time.</li>
<li><code>autoSub(ev, listener)</code>: Subscribes a listener to an event but such that
if this is called from within a <code>bind</code> context, the listener will be
properly cleaned up (unsubscribed) on context disposal.  Returns the
subscription ID.</li>
<li><code>concat(arrays...)</code>: returns a dependent array that is the result of
concatenating multiple <code>ObsArray</code>s (efficiently maintained).</li>
</ul>
<p><strong><code>ObsCell</code> members</strong></p>
<ul>
<li><code>get()</code>: return current value of the cell</li>
<li><code>onSet</code>: the event that is fired after the value of the cell is
changed.  The event data is an array of two elements, <code>[oldVal, newVal]</code>.</li>
</ul>
<p><strong><code>SrcCell</code> members</strong></p>
<ul>
<li><code>set(x)</code>: set value of cell to <code>x</code> and return old value of <code>x</code></li>
<li>inherits <code>ObsCell</code></li>
</ul>
<p><strong><code>DepCell</code> members</strong></p>
<ul>
<li>inherits <code>ObsCell</code></li>
<li><code>disconnect</code>: unsubscribes this cell from its dependencies and
recursively disconnects all nested binds; useful for manual disposal of
<code>bind</code>s</li>
</ul>
<p><strong><code>ObsArray</code> members</strong></p>
<ul>
<li><code>at(i)</code>: return element at <code>i</code></li>
<li><code>all()</code>: return array copy of all elements</li>
<li><code>raw()</code>: return raw array of all elements; this is unsafe since mutations
will violate the encapsulated invariants, but serves as a performance
escape hatch around <code>all()</code></li>
<li><code>length()</code>: return size of the array</li>
<li><code>map(fn)</code>: return <code>DepArray</code> of given function mapped over this array</li>
<li><code>onChange</code>: the event that is fired after any part of the array is
changed.  The event data is an array of three elements: <code>[index, added,
removed]</code>, where <code>index</code> is the index where the change occurred, <code>added</code>
is the sub-array of elements that were added, and <code>removed</code> is the
sub-array of elements that were removed.</li>
</ul>
<p><strong><code>SrcArray</code> members</strong></p>
<ul>
<li><code>splice(index, count, additions...)</code>: replace <code>count</code> elements starting at
<code>index</code> with <code>additions</code></li>
<li><code>insert(x, i)</code>: insert value <code>x</code> at index <code>i</code></li>
<li><code>remove(x)</code>: find and remove first occurrence of <code>x</code></li>
<li><code>removeAt(i)</code>: remove element at index <code>i</code></li>
<li><code>push(x)</code>: append <code>x</code> to the end of the array</li>
<li><code>put(i, x)</code>: replace element <code>i</code> with value <code>x</code></li>
<li><code>replace(xs)</code>: replace entire array with raw array <code>xs</code></li>
<li>inherits <code>ObsArray</code></li>
</ul>
<p><strong><code>DepArray</code> members</strong></p>
<ul>
<li>inherits <code>ObsArray</code></li>
</ul>
<p><strong><code>ObsMap</code> members</strong></p>
<ul>
<li><code>get(k)</code>: return value associated with key <code>k</code></li>
<li><code>all()</code>: return raw object copy</li>
<li><code>onAdd</code>: the event that is fired after an element is added.  The event
data is <code>[key, newVal]</code>.</li>
<li><code>onRemove</code>: the event that is fired after an element is removed.  The
event data is <code>[key, oldVal]</code>.</li>
<li><code>onChange</code>: the event that is fired after a key&#39;s value is changed.  The
event data is <code>[key, oldVal, newVal]</code>.</li>
</ul>
<p><strong><code>SrcMap</code> members</strong></p>
<ul>
<li><code>put(k, v)</code>: associate value <code>v</code> with key <code>k</code> and return any prior value associated with <code>k</code></li>
<li><code>remove(k)</code>: remove the entry associated at key <code>k</code></li>
<li>inherits <code>ObsMap</code></li>
</ul>
<p><strong><code>DepMap</code> members</strong></p>
<ul>
<li>inherits <code>ObsMap</code></li>
</ul>
<p><strong><code>Ev</code> members</strong></p>
<ul>
<li><code>sub(listener)</code>: subscribes a listener function for events from this
event node and returns a unique ID for this subscription, which can be used
as the handle by which to unsubscribe later.  The listener takes a single
argument, whose type depends on the event, and is called every time an
event is fired on this event node.</li>
<li><code>pub(data)</code>: publish an event, described by the data in <code>data</code>.  <code>data</code>
is what will be passed to all the subscribed listeners.</li>
<li><code>unsub(subscriptionId)</code>: detaches a listener from this event.</li>
</ul>
<h2><a name="rxt-namespace"><code>rxt</code> Namespace</a></h2>
<p>This contains the template DSL constructs.  Main thing here is the <em>tag
function</em>, which is what constructs a DOM element.</p>
<p><strong>Free functions</strong></p>
<ul>
<li><code>mktag(tag)</code>: returns a tag function of the given tag name.  The various
tags like <code>div</code> and <code>h2</code> are simply aliases; e.g., <code>div = mktag(&#39;div&#39;)</code>.
Tag functions themselves take <code>(attrs, contents)</code>, both optional, where
<code>attrs</code> is a JavaScript object of HTML attributes and/or <em>special
attributes</em> and <code>contents</code> is an array (<code>ObsArray</code> or regular <code>Array</code>) of
child nodes (either raw elements, <code>RawHtml</code>, or jQuery objects) and/or
strings (for text nodes).  You can also pass in a singular such node
without the array.  The function returns an instance of the specified
element wrapped in a jQuery object.  See also <code>specialAttrs</code> below for
more on special attributes.</li>
<li><code>importTags([dest])</code>: populate the global namespace (or the <code>dest</code> object
if given) with the tag symbols, so you don&#39;t need have <code>rxt</code> all over
your templates.  Useful for quickly throwing something together.</li>
<li><code>rawHtml(html)</code>: returns a <code>RawHtml</code> wrapper for strings that tags won&#39;t
escape when rendering; example: <code>div {}, [rawHtml(&#39;&lt;span&gt;hello&lt;/span&gt;&#39;)]</code></li>
<li><code>rxt.cast(opts, types)</code>: convenience utility for use in preparing
arguments for a component.  <code>opts</code> is the arguments object mapping, and
<code>types</code> is an object mapping fields of <code>opts</code> to either <code>cell</code> or
<code>array</code>.  <code>cast</code> returns a copy of <code>opts</code> but with the fields casted
based on the specified desired <code>types</code> (yielding observable cells and
arrays).</li>
<li><code>rxt.cssify(props)</code>: convenience utility for programmatically constructing
strings suitable for use as a <code>style</code> attribute.  Takes an object mapping
camelCase versions of style property names and values that are either
strings (which are put in verbatim), numbers (which are written as pixels),
or null/undefined (which omits that property altogether).</li>
<li>Tags: <code>p</code>, <code>br</code>, <code>ul</code>, <code>li</code>, <code>span</code>, <code>anchor</code>, <code>div</code>, <code>input</code>, <code>select</code>,
<code>option</code>, <code>label</code>, <code>button</code>, <code>fieldset</code>, <code>legend</code>, <code>section</code>, <code>header</code>,
<code>footer</code>, <code>strong</code>, <code>h1</code>, <code>h2</code>, <code>h3</code>, <code>h4</code>, <code>h5</code>, <code>h6</code>, <code>h7</code></li>
</ul>
<p><strong>jQuery plug-in</strong></p>
<ul>
<li><code>rx(property)</code>: lazily create (or take the cached instance) of a cell whose
value is maintained to reflect the desired property on the element.
<code>property</code> can be <code>&#39;checked&#39;</code>, <code>&#39;focused&#39;</code>, or <code>&#39;val&#39;</code>.  Returns the cell.</li>
</ul>
<p><strong>Special attributes</strong></p>
<p><em>Special attributes</em> are handled differently from normal.  The built-in
special attributes are primarily events like <code>click</code>:</p>
<div class="highlight"><pre><span class="nx">button</span> <span class="p">{</span><span class="nv">click: </span><span class="nf">-&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s">&#39;hello&#39;</span><span class="p">)},</span> <span class="s">&#39;Hello&#39;</span>
</pre></div>

<p>Special attributes are really just a convenient short-hand for running the
handler functions after constructing object.  The above example is equivalent to:</p>
<div class="highlight"><pre><span class="nv">$button = </span><span class="nx">button</span> <span class="s">&#39;Hello&#39;</span>
<span class="nx">$button</span><span class="p">.</span><span class="nx">click</span> <span class="nf">-&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s">&#39;hello&#39;</span><span class="p">)</span>
</pre></div>

<p>The built-in special attributes available include:</p>
<ul>
<li><p><code>init</code>: which is a 0-ary function that is run immediately upon
instantiation of the element.</p>
</li>
<li><p>events like <code>click</code>, <code>focus</code>, <code>mouseleave</code>, <code>keyup</code>, <code>load</code>, etc.,:
these are available for all jQuery events.  The handlers are similar to
those you would pass to a jQuery event method—they take a jQuery event
and return false to stop propagation—but the context is the
jQuery-wrapped element instead of the raw element.  The full list:</p>
<ul>
<li><code>blur</code></li>
<li><code>change</code></li>
<li><code>click</code></li>
<li><code>dblclick</code></li>
<li><code>error</code></li>
<li><code>focus</code></li>
<li><code>focusin</code></li>
<li><code>focusout</code></li>
<li><code>hover</code></li>
<li><code>keydown</code></li>
<li><code>keypress</code></li>
<li><code>keyup</code></li>
<li><code>load</code></li>
<li><code>mousedown</code></li>
<li><code>mouseenter</code></li>
<li><code>mouseleave</code></li>
<li><code>mousemove</code></li>
<li><code>mouseout</code></li>
<li><code>mouseover</code></li>
<li><code>mouseup</code></li>
<li><code>ready</code></li>
<li><code>resize</code></li>
<li><code>scroll</code></li>
<li><code>select</code></li>
<li><code>submit</code></li>
<li><code>toggle</code></li>
<li><code>unload</code></li>
</ul>
</li>
</ul>
<p><code>specialAttrs</code>: an object mapping special attribute names to the functions
that handle them.  When an element specifies a special attribute, this
handler function is invoked.  The handler function takes <code>(element, value,
attrs, contents)</code>, where:</p>
<ul>
<li><code>element</code> is the element being operated on</li>
<li><code>value</code> is the value of this special attribute for <code>element</code></li>
<li><code>attrs</code> is the full map of attributes for <code>element</code></li>
<li><code>contents</code> is the content/children for <code>element</code> (which can be a
string, <code>RawHtml</code>, array, <code>ObsCell</code>, or <code>ObsArray</code>)</li>
</ul>
<p>So for instance, we can create a special attribute <code>drag</code> that just
forwards to the jQuery <code>[jdragdrop]</code> plug-in:</p>
<div class="highlight"><pre><span class="nv">rxt.specialAttrs.drag = </span><span class="nf">(elt, fn, attrs, contents) -&gt;</span> <span class="nx">elt</span><span class="p">.</span><span class="nx">drag</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
</pre></div>

<p>and then use it like so in your templates:</p>
<div class="highlight"><pre><span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;block&#39;</span><span class="p">,</span> <span class="nv">drag: </span><span class="nf">-&gt;</span> <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">css</span><span class="p">(</span><span class="s">&#39;top&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">offsetY</span><span class="p">)}</span>
</pre></div>


        </section>
      </div>
    </div><!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-41900480-1', 'yang.github.io');
      ga('send', 'pageview');
    </script>
    <footer>
      <div class="inner"><p>Copyright 2013 Reactive Coffee Authors.<br>Code licensed under <a href="https://github.com/yang/reactive-coffee/blob/master/LICENSE">MIT License</a>.  Documentation licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.<br>Website design based on Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>

      </div>
    </footer>
  </body>
</html>