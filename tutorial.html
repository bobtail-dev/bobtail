<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="styles/9981d504.main.css" media="screen">
    <title>Tutorial - bobtail</title>
  </head>
  <body>
    <header>
      <div class="overlay"></div>
      <div class="inner">
        <h1 class="smaller-title"><a href="/reactive-coffee/">bobtail</a></h1>
        <nav class="top-nav">
          <div class="inner-inner"><a href="quickstart.html">Documentation</a><a href="support.html">Community/Support</a><a href="design.html">Rationale</a><a href="dev-setup.html">Development</a></div>
        </nav>
      </div>
    </header>
    <div id="content-wrapper">
      <div class="inner clearfix">
        <nav class="side-nav">
          <ul>
            <li><a href="quickstart.html">Quickstart Examples</a></li>
            <li><a href="tutorial.html" class="current">Tutorial</a><ul class="toc"><li><a href="#getting-started">Getting Started</a></li><li><a href="#cells">Cells</a></li><li><a href="#events">Events</a></li><li><a href="#dependent-cells">Dependent Cells</a></li><li><a href="#transactions">Transactions</a></li><li><a href="#arrays-and-maps">Arrays and Maps</a></li><li><a href="#object-oriented-programming--a-pattern-for-public-and-private-cells-">Object-Oriented Programming: A Pattern for Public and Private cells.</a></li><li><a href="#static-templates">Static Templates</a></li><li><a href="#reactive-templates">Reactive Templates</a></li><li><a href="#more-on-arrays-and-reactive-templates">More on Arrays and Reactive Templates</a></li><li><a href="#components">Components</a></li><li><a href="#binding-to-dom-element-attributes">Binding To DOM Element Attributes</a></li><li><a href="#lifting">Lifting</a></li><li><a href="#anti-pattern--non-nesting">Anti-Pattern: Non-Nesting</a></li><li><a href="#next-steps">Next Steps</a></li></ul></li>
            <li><a href="advanced.html">Advanced Concepts</a></li>
            <li><a href="api.html">API Reference</a></li>
            <li><a href="changes.html">Change Log</a></li>
          </ul>
        </nav>
        <section id="main-content"><h1 id="tutorial">Tutorial</h1>
<h2 id="getting-started"><a name="getting-started">Getting Started</a></h2>
<p>Bobtail depends on jQuery and Underscore:</p>
<div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&#39;//ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js&#39;</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&#39;//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.4/underscore-min.js&#39;</span><span class="nt">&gt;&lt;/script&gt;</span>
</pre></div>

<p>Bobtail is hosted on <a href="http://cdnjs.com/">cdnjs</a> as well, so you can source directly from there:</p>
<div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&#39;//cdnjs.cloudflare.com/ajax/libs/reactive-coffee/1.3.0/reactive-coffee.min.js&#39;</span><span class="nt">&gt;&lt;/script&gt;</span>
</pre></div>

<p>If you&#39;re using node (or browserify, etc.), you can install via NPM:</p>
<pre><code>npm install --save bobtail</code></pre>
<p>If you&#39;re using <a href="http://bower.io/">Bower</a>, you can also add Bobtail as a dependency for your
project:</p>
<pre><code>bower install --save bobtail</code></pre>
<p>This will transitively pull in the above dependencies for Bobtail
(temp. note: bower <a href="https://github.com/bower/bower/issues/540">has issues solving dependency version
constraints</a>).</p>
<p>If you are not using server-side CoffeeScript compilation (recommended for
production), you can get started quickly with client-side compilation:</p>
<div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&#39;//cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js&#39;</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/coffeescript&quot;</span><span class="nt">&gt;</span>
  <span class="err">#</span> <span class="nx">Your</span> <span class="nx">code</span> <span class="nx">goes</span> <span class="nx">here</span><span class="o">!</span>
<span class="nt">&lt;/script&gt;</span>
</pre></div>

<p>To follow along with these examples and use reactive HTML element tags
without having to use their fully qualified name in <code>rx.rxt.tags</code>, include
this at the top of your CoffeeScript:</p>
<div class="highlight"><pre><span class="nx">rx</span><span class="p">.</span><span class="nx">rxt</span><span class="p">.</span><span class="nx">importTags</span><span class="p">()</span>
</pre></div>

<p>This lets you write:</p>
<div class="highlight"><pre><span class="nx">span</span> <span class="s">&#39;hello world&#39;</span>
</pre></div>

<p>Alternatively, to use without polluting the global namespace (recommended
for larger-scale apps), just shorten the namespace prefix:</p>
<div class="highlight"><pre><span class="nv">T = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">rxt</span><span class="p">.</span><span class="nx">tags</span>
<span class="nx">T</span><span class="p">.</span><span class="nx">span</span> <span class="s">&#39;hello world&#39;</span>
</pre></div>

<p>The following examples also lift <code>rx.bind</code> out of its namespace:</p>
<div class="highlight"><pre><span class="nv">bind = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">bind</span>
</pre></div>

<p>You can play with the following examples in this <a href="http://jsfiddle.net/yang/fcJxP/">minimal jsFiddle</a>.</p>
<h2 id="cells"><a name="cells">Cells</a></h2>
<p>The core building block is an <em>observable cell</em>, <code>ObsCell</code>.</p>
<div class="highlight"><pre><span class="nv">x = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">()</span>
</pre></div>

<p>A cell is just a container for a value (initialized to <code>undefined</code> above, but
you could also have passed in an initial value).  You can <code>get</code>/<code>set</code> this
value:</p>
<div class="highlight"><pre><span class="nv">x = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="c1"># 3</span>
</pre></div>

<p>You can put arbitrary values into cells, such as arrays and objects.</p>
<h2 id="events"><a name="events">Events</a></h2>
<p>The special thing about observables is that you can <em>subscribe</em> to events on
them, where events are fired when the value of the cell changes in some way.
For simple cells like the above, there&#39;s just a single <em>on-set</em> event type:</p>
<div class="highlight"><pre><span class="nv">subscriptionId = </span><span class="nx">x</span><span class="p">.</span><span class="nx">onSet</span><span class="p">.</span><span class="nx">sub</span> <span class="nf">([oldVal, newVal]) -&gt;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="s">&quot;x was set from </span><span class="si">#{</span><span class="nx">oldVal</span><span class="si">}</span><span class="s"> to </span><span class="si">#{</span><span class="nx">newVal</span><span class="si">}</span><span class="s">&quot;</span>
</pre></div>

<p>The listener is just a simple callback.  All event types take callbacks of a
single argument—the type of that argument is event-specific, and in the case of
<code>onSet</code> it&#39;s a pair of <code>[old value, new value]</code>.  The <code>sub</code> method returns a
unique identifier for this subscription, which can later be used to unsubscribe
a listener:</p>
<div class="highlight"><pre><span class="nx">x</span><span class="p">.</span><span class="nx">onSet</span><span class="p">.</span><span class="nx">unsub</span><span class="p">(</span><span class="nx">subscriptionId</span><span class="p">)</span>
</pre></div>

<p>Once subscribed, you can start reacting to its events.  For instance:</p>
<div class="highlight"><pre><span class="nv">firstName = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="s">&#39;John&#39;</span><span class="p">)</span>
<span class="c1"># This ensures .name will always reflect the firstName</span>
<span class="nx">firstName</span><span class="p">.</span><span class="nx">onSet</span><span class="p">.</span><span class="nx">sub</span> <span class="nf">([oldVal, newVal]) -&gt;</span>
  <span class="nx">$</span><span class="p">(</span><span class="s">&#39;.name&#39;</span><span class="p">).</span><span class="nx">text</span><span class="p">(</span><span class="nx">newVal</span><span class="p">)</span>
<span class="nx">firstName</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s">&#39;Jane&#39;</span><span class="p">)</span>
</pre></div>

<p>Events immediately invoke a newly added listener to bring them up to speed
on the current value, but you can suppress this first invocation with the
simple <code>rx.skipFirst</code> utility function:</p>
<div class="highlight"><pre><span class="nx">x</span><span class="p">.</span><span class="nx">onSet</span><span class="p">.</span><span class="nx">sub</span> <span class="nx">rx</span><span class="p">.</span><span class="nx">skipFirst</span> <span class="nf">([oldVal, newVal]) -&gt;</span> <span class="p">...</span>
</pre></div>

<h2 id="dependent-cells"><a name="dependent-cells">Dependent Cells</a></h2>
<p>The above is a simple way of observing and responding to events on cells,
but it&#39;s a bit verbose.  In most UIs, you really just want to be able to
declaratively express your views in terms of a model (data binding), rather
than explicitly manage listeners.</p>
<p>To extend the above example, let&#39;s say you now had a displayed name that
depended on two cells (comprising your &quot;model&quot;).  You could just create
explicit subscriptions and listeners:</p>
<div class="highlight"><pre><span class="nv">firstName = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="s">&#39;John&#39;</span><span class="p">)</span>
<span class="nv">lastName = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="s">&#39;Smith&#39;</span><span class="p">)</span>

<span class="nv">updateName = </span><span class="nf">-&gt;</span>
  <span class="nx">$</span><span class="p">(</span><span class="s">&#39;.name&#39;</span><span class="p">).</span><span class="nx">text</span><span class="p">(</span><span class="s">&quot;</span><span class="si">#{</span><span class="nx">firstName</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span><span class="si">}</span><span class="s"> </span><span class="si">#{</span><span class="nx">lastName</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span><span class="si">}</span><span class="s">&quot;</span><span class="p">)</span>
<span class="nx">firstName</span><span class="p">.</span><span class="nx">onSet</span><span class="p">.</span><span class="nx">sub</span> <span class="nf">-&gt;</span> <span class="nx">updateName</span>
<span class="nx">lastName</span><span class="p">.</span><span class="nx">onSet</span><span class="p">.</span><span class="nx">sub</span> <span class="nf">-&gt;</span> <span class="nx">updateName</span>

<span class="nx">firstName</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s">&#39;Jane&#39;</span><span class="p">)</span>
<span class="nx">lastName</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s">&#39;Doe&#39;</span><span class="p">)</span>
</pre></div>

<p>However, the primary way in which these cells are to be composed is via <code>bind</code>,
which lets you simply write an expression or function in terms of the dependent
nodes:</p>
<div class="highlight"><pre><span class="nv">fullName = </span><span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">firstName</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span><span class="si">}</span><span class="s"> </span><span class="si">#{</span><span class="nx">lastName</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span><span class="si">}</span><span class="s">&quot;</span>
</pre></div>

<p>Now, <code>fullName</code> is always bound to the <code>firstName + lastName</code>.  Key here is
that no explicit subscription management is necessary.  This scales well to
more complex dependencies, and is more readable/declarative:</p>
<div class="highlight"><pre><span class="nv">displayName = </span><span class="nx">bind</span> <span class="nf">-&gt;</span>
  <span class="k">if</span> <span class="nx">showRealName</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
    <span class="s">&quot;Full name: </span><span class="si">#{</span><span class="nx">fullName</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span><span class="si">}</span><span class="s">&quot;</span>
  <span class="k">else</span>
    <span class="s">&quot;Fake name: </span><span class="si">#{</span><span class="nx">fakeName</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span><span class="si">}</span><span class="s">&quot;</span>
</pre></div>

<p>The bindings are managed such that only the dependent cells that could possibly
affect the result are effective dependencies.  In this example, at any moment,
<code>fullName</code> depends either only on <code>showRealName</code> and <code>fullName</code> <em>or</em> only on
<code>showRealName</code> and <code>fakeName</code>.  If <code>showRealName</code> is false, changes to
<code>firstName</code> and <code>lastName</code> will not trigger a re-render of the <code>.name</code>.</p>
<p><code>firstName</code> and <code>lastName</code> are <em>source cells</em> that support setting of values.
<code>fullName</code> is itself also a cell, but a &quot;read-only&quot; <em>dependent cell</em> that we
can bind to some expression of source cells.  These do not have a <code>set</code> method.</p>
<p>Dependent cells can in turn be bound to as well:</p>
<div class="highlight"><pre><span class="nv">greeting = </span><span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="s">&quot;Welcome back </span><span class="si">#{</span><span class="nx">fullName</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span><span class="si">}</span><span class="s">!&quot;</span>
</pre></div>

<p>These bindings can form an arbitrary DAG.</p>
<p>Reactive programming is the same concept behind how spreadsheet calculations
work, and is similar to the data-binding feature present in many of the other
frameworks—which is an effective paradigm for frontend UI development—but
instead of being exclusively applied to view components, typically confined to
a template language, this is generalized to be a generic way of expressing
arbitrary time-varying data structures.</p>
<p>When you set a cell to the same value (value doesn&#39;t change), the event is
not propagated.  This is a useful efficiency boost that assumes/encourages
you to think of binds/cells not as reacting to discrete events, but more
abstractly as continuous time-varying signals.  In general, your cells are
encouraged to be deterministic in their effects, if not <a href="https://en.wikipedia.org/wiki/Pure_function">pure functions</a>
altogether.</p>
<h2 id="transactions"><a name="transactions">Transactions</a></h2>
<p>Sometimes you want to make a more complex update on some cells, while
preserving certain semantics/invariants over them.  For instance, consider
two cells representing the balances in two different bank accounts.  When
transferring funds from one to the other, there will transiently be a
moment when the total funds across both will be either greater or less than
what it really should be:</p>
<div class="highlight"><pre><span class="nv">a = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="nv">b = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nv">sum = </span><span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="o">+</span> <span class="nx">b</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
<span class="c1"># sum should always be 8, but when transferring 1 from a to b...</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1"># sum is now 7!</span>
<span class="nx">b</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1"># sum back to 8</span>
</pre></div>

<p>To prevent these &quot;glitches&quot; from being visible, we can bundle up the
operations into a <em>transaction</em>.  Throughout the duration of this
transaction, events will not be propagated.  For instance:</p>
<div class="highlight"><pre><span class="nx">rx</span><span class="p">.</span><span class="nx">transaction</span> <span class="o">=&gt;</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="c1"># sum will not yet have received any events</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1"># now sum will have received notifications, but it will see that the `a`</span>
<span class="c1"># and `b` still sum to 8.</span>
</pre></div>

<h2 id="arrays-and-maps"><a name="arrays-and-maps">Arrays and Maps</a></h2>
<p>Cells are the most general type of observable container.  However, there are
also observable containers with special support for arrays and maps
(that is, Javascript objects, which are basically maps).  This specialized
support is for more efficient and fine-grained event types reflecting
changes to particular sub-parts rather than an all-encompassing <code>onSet</code>
event whenever any part of the array or map changes.</p>
<p>For instance, arrays commonly have elements inserted into or removed from
them, in which case we&#39;d like to avoid re-rendering entire dependent
sections of the DOM or otherwise needing to figure out what parts have
changed (the relationship between these reactive data structures and DOM
UI rendering will be explained in later sections).</p>
<p>Arrays support an <code>onChange</code> event.  It fires
with a triple <code>[index, removed, added]</code>, where <code>index</code> is the offset into the
array where the change is happening, <code>removed</code> is the sub-array of elements
removed, and <code>added</code> is the sub-array of elements inserted.  Example:</p>
<div class="highlight"><pre><span class="nv">xs = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="nx">xs</span><span class="p">.</span><span class="nx">onChange</span><span class="p">.</span><span class="nx">sub</span> <span class="nf">([index, removed, added]) -&gt;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="s">&quot;replaced </span><span class="si">#{</span><span class="nx">removed</span><span class="p">.</span><span class="nx">length</span><span class="si">}</span><span class="s"> element(s) at offset </span><span class="si">#{</span><span class="nx">index</span><span class="si">}</span><span class="s"> with </span><span class="si">#{</span><span class="nx">added</span><span class="p">.</span><span class="nx">length</span><span class="si">}</span><span class="s"> new element(s)&quot;</span>
<span class="nx">xs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="c1"># replaced 0 element(s) at offset 3 with 1 new element(s)</span>
</pre></div>

<p>From a declarative point of view, you can define a <em>dependent array</em> to be
a mapped transformation of a <em>source array</em>:</p>
<div class="highlight"><pre><span class="nv">ys = </span><span class="nx">xs</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(x) -&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">x</span>
<span class="c1"># ys.all() is now [2, 4, 6, 8]</span>
<span class="nx">xs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="c1"># ys.all() is now [2, 4, 6, 8, 10]</span>
</pre></div>

<p>Besides <code>push</code> as shown in the above example, there are a few other
mutation methods built in.  Some are modeled after Javascript&#39;s <code>Array</code>
methods, e.g. <code>splice</code>, while others are new, e.g. <code>insert</code>.</p>
<p>However, for arbitrary transformations of arrays, you can use the <code>update</code>
method, which actually does the smart thing and performs a diff between the
old and new contents of the array, so as to minimize the downstream
dependencies.  So in fact, you could implement all other update methods in
terms of <code>update</code>.  The above <code>push</code> example could also have been written
with <code>xs.update(xs.all().concat([4]))</code>, and that would have similarly
resulted in just a single element insertion in the downstream mapped array.</p>
<p>In the same spirit, you can convert an <code>ObsCell</code> containing an array to a
<code>DepArray</code> with <code>cellToArray</code>, which simply maintains the <code>DepArray</code> via
the <code>update</code> mechanism (diffing and issuing minimal downstream change
events):</p>
<div class="highlight"><pre><span class="nv">cell = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="nv">xs = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cellToArray</span><span class="p">(</span><span class="nx">cell</span><span class="p">)</span>
<span class="nx">xs</span><span class="p">.</span><span class="nx">onChange</span><span class="p">.</span><span class="nx">sub</span> <span class="nf">([index, removed, added]) -&gt;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="s">&quot;replaced </span><span class="si">#{</span><span class="nx">removed</span><span class="p">.</span><span class="nx">length</span><span class="si">}</span><span class="s"> element(s) at offset </span><span class="si">#{</span><span class="nx">index</span><span class="si">}</span><span class="s"> with </span><span class="si">#{</span><span class="nx">removed</span><span class="p">.</span><span class="nx">length</span><span class="si">}</span><span class="s"> new element(s)&quot;</span>
<span class="nx">cell</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">cell</span><span class="p">.</span><span class="nx">get</span><span class="p">().</span><span class="nx">concat</span><span class="p">([</span><span class="mi">4</span><span class="p">]))</span>
<span class="c1"># replaced 0 element(s) at offset 3 with 1 new element(s)</span>
</pre></div>

<p><em>Objects</em> also exist, but are called <em>maps</em>.  They are pretty
straightforward as regular containers:</p>
<div class="highlight"><pre><span class="nv">months = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">map</span><span class="p">()</span>
<span class="nx">months</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s">&#39;Mar&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nx">months</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s">&#39;Aug&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="nx">months</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s">&#39;Oct&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="nx">months</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s">&#39;Mar&#39;</span><span class="p">)</span> <span class="c1"># 3</span>
<span class="nx">months</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="s">&#39;Oct&#39;</span><span class="p">)</span> <span class="c1"># 10</span>
<span class="nx">months</span><span class="p">.</span><span class="nx">all</span><span class="p">()</span> <span class="c1"># {&quot;Mar&quot;: 3, &quot;Aug&quot;: 8}</span>
</pre></div>

<p>With maps, there are three different event types:</p>
<div class="highlight"><pre><span class="nv">months = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">map</span><span class="p">({</span><span class="s">&quot;Mar&quot;</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Aug&quot;</span><span class="o">:</span> <span class="mi">8</span><span class="p">})</span>
<span class="nx">months</span><span class="p">.</span><span class="nx">onAdd</span><span class="p">.</span><span class="nx">sub</span> <span class="nf">([key, val]) -&gt;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="s">&quot;set </span><span class="si">#{</span><span class="nx">key</span><span class="si">}</span><span class="s"> to </span><span class="si">#{</span><span class="nx">val</span><span class="si">}</span><span class="s">&quot;</span>
<span class="c1"># set Mar to 3</span>
<span class="c1"># set Aug to 8</span>
<span class="nx">months</span><span class="p">.</span><span class="nx">onChange</span><span class="p">.</span><span class="nx">sub</span> <span class="nf">([key, oldVal, newVal]) -&gt;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="s">&quot;updated </span><span class="si">#{</span><span class="nx">key</span><span class="si">}</span><span class="s"> (which had mapped to </span><span class="si">#{</span><span class="nx">oldVal</span><span class="si">}</span><span class="s">) to </span><span class="si">#{</span><span class="nx">newVal</span><span class="si">}</span><span class="s">&quot;</span>
<span class="nx">months</span><span class="p">.</span><span class="nx">onRemove</span><span class="p">.</span><span class="nx">sub</span> <span class="nf">([key, val]) -&gt;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="s">&quot;removed </span><span class="si">#{</span><span class="nx">key</span><span class="si">}</span><span class="s"> which had mapped to </span><span class="si">#{</span><span class="nx">val</span><span class="si">}</span><span class="s">&quot;</span>

<span class="nx">months</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s">&#39;May&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1"># set May to 5</span>
<span class="nx">months</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s">&#39;Mar&#39;</span><span class="p">,</span> <span class="s">&#39;three&#39;</span><span class="p">)</span>
<span class="c1"># updated Mar (which had mapped to 3) to three</span>
<span class="nx">months</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="s">&#39;Oct&#39;</span><span class="p">)</span>
<span class="c1"># removed Aug which had mapped to 8</span>
</pre></div>

<p>The key to maps is that you can bind to changes to just certain keys.  For
instance, if you had:</p>
<div class="highlight"><pre><span class="nv">mar = </span><span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">months</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s">&#39;Mar&#39;</span><span class="p">)</span>
<span class="nv">dec = </span><span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">months</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s">&#39;Dec&#39;</span><span class="p">)</span>
</pre></div>

<p>Then <code>mar</code> will be re-evaluated only when the <code>&quot;Mar&quot;</code> key is
changed/removed, and <code>dec</code> will only when the <code>&quot;Dec&quot;</code> key is inserted.</p>
<h2 id="object-oriented-programming-a-pattern-for-public-and-private-cells-"><a name="object-oriented-programming--a-pattern-for-public-and-private-cells-">Object-Oriented Programming: A Pattern for Public and Private cells.</a></h2>
<p>Often, when using an object-oriented approach, one wants to expose values to the user without permitting them
to change those values directly. When using reactive, we would also want the user to be able to subscribe
listeners. to these private cells. In addition, we still need to be able to set the value of the cell internally.
To achieve this,  we can make use of <code>rx.bind</code>, which returns a <code>DepCell</code> object. These objects do not have a
set method, and thus cannot be directly mutated by the user:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nx">Incrementer</span>
  <span class="nv">constructor: </span><span class="nf">-&gt;</span>
    <span class="nv">_value = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># private field which can be freely changed within this constructor&#39;s scope.</span>
    <span class="vi">@value = </span><span class="nx">bind</span> <span class="o">=&gt;</span> <span class="nx">_value</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="c1"># public field; its value mirrors that of _value, but cannot be directly changed by the user.</span>
    <span class="vi">@increment = </span><span class="o">=&gt;</span> <span class="nx">_value</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="nv">inc = </span><span class="k">new</span> <span class="nx">Incrementer</span><span class="p">()</span>
<span class="nx">inc</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">onSet</span><span class="p">.</span><span class="nx">sub</span> <span class="nf">([oldVal, newVal]) -&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newVal</span><span class="p">)</span>
<span class="nx">inc</span><span class="p">.</span><span class="nx">increment</span><span class="p">()</span> <span class="c1"># prints 1</span>
<span class="nx">inc</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="c1"># error, not allowed.</span>
</pre></div>

<p>The usefulness of this pattern is not limited to object oriented programming. We can use this any time we wish to return
a read-only cell:</p>
<div class="highlight"><pre><span class="nv">autoIncrementedCell = </span><span class="nf">(start) -&gt;</span>
  <span class="nv">value = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="nx">start</span><span class="p">)</span>
  <span class="nx">setInterval</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1000</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">value</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>

<span class="nv">c = </span><span class="nx">autoIncrementedCell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">onSet</span><span class="p">.</span><span class="nx">sub</span> <span class="nf">([oldVal, newVal]) -&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newVal</span><span class="p">)</span>
</pre></div>

<h2 id="static-templates"><a name="static-templates">Static Templates</a></h2>
<p>Now for a brief jump to something entirely different from reactive
programming....</p>
<p>The &quot;template&quot; system is implemented as an embedded domain-specific language
(DSL) in CoffeeScript, which happens to have a syntax that <a href="https://github.com/jashkenas/coffee-script/wiki/%5Bextensibility%5D-writing-DSLs">lends itself
well</a> to expressing the template structure.</p>
<p>Here&#39;s a simple template:</p>
<div class="highlight"><pre><span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;sidebar&#39;</span><span class="p">},</span> <span class="p">[</span>
  <span class="nx">h2</span> <span class="p">{},</span> <span class="p">[</span><span class="s">&#39;Send a message&#39;</span><span class="p">]</span>
  <span class="nx">form</span> <span class="p">{</span><span class="nv">action: </span><span class="s">&#39;/msg&#39;</span><span class="p">,</span> <span class="nv">method: </span><span class="s">&#39;POST&#39;</span><span class="p">},</span> <span class="p">[</span>
    <span class="nx">input</span> <span class="p">{</span><span class="nv">type: </span><span class="s">&#39;text&#39;</span><span class="p">,</span> <span class="nv">name: </span><span class="s">&#39;comment&#39;</span><span class="p">,</span> <span class="nv">placeholder: </span><span class="s">&#39;Your message&#39;</span><span class="p">},</span> <span class="p">[]</span>
    <span class="nx">select</span> <span class="p">{</span><span class="nv">name: </span><span class="s">&#39;recipient&#39;</span><span class="p">},</span> <span class="p">[</span>
      <span class="nx">option</span> <span class="p">{</span><span class="nv">value: </span><span class="s">&#39;0&#39;</span><span class="p">},</span> <span class="p">[</span><span class="s">&#39;John&#39;</span><span class="p">]</span>
      <span class="nx">option</span> <span class="p">{</span><span class="nv">value: </span><span class="s">&#39;1&#39;</span><span class="p">},</span> <span class="p">[</span><span class="s">&#39;Jane&#39;</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="nx">button</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;submit-btn&#39;</span><span class="p">},</span> <span class="p">[</span><span class="s">&#39;Send&#39;</span><span class="p">]</span>
  <span class="p">]</span>
<span class="p">]</span>
</pre></div>

<p>It translates to the following HTML:</p>
<div class="highlight"><pre><span class="o">&lt;</span><span class="nx">div</span> <span class="k">class</span><span class="o">=</span><span class="s">&quot;sidebar&quot;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="nx">Send</span> <span class="nx">a</span> <span class="nx">message</span><span class="o">&lt;/</span><span class="nx">h2</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">form</span> <span class="nx">action</span><span class="o">=</span><span class="s">&#39;/msg&#39;</span> <span class="nx">method</span><span class="o">=</span><span class="s">&#39;POST&#39;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="s">&#39;text&#39;</span> <span class="nx">name</span><span class="o">=</span><span class="s">&#39;comment&#39;</span> <span class="nx">placeholder</span><span class="o">=</span><span class="s">&#39;Your message&#39;</span><span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="nx">select</span> <span class="nx">name</span><span class="o">=</span><span class="s">&#39;recipient&#39;</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">option</span> <span class="nx">value</span><span class="o">=</span><span class="s">&#39;0&#39;</span><span class="o">&gt;</span><span class="nx">John</span><span class="o">&lt;/</span><span class="nx">option</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">option</span> <span class="nx">value</span><span class="o">=</span><span class="s">&#39;1&#39;</span><span class="o">&gt;</span><span class="nx">Jane</span><span class="o">&lt;/</span><span class="nx">option</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="nx">select</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">button</span> <span class="k">class</span><span class="o">=</span><span class="s">&#39;submit-btn&#39;</span><span class="o">&gt;</span><span class="nx">Send</span><span class="o">&lt;/</span><span class="nx">button</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="nx">form</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nx">div</span><span class="o">&gt;</span>
</pre></div>

<p>Note how the children of a DOM node are always lists, even when it&#39;s just a single text node.</p>
<p>Since this is CoffeeScript, you can embed arbitrary logic:</p>
<div class="highlight"><pre><span class="c1"># Loops:</span>

<span class="nx">ul</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;friends&#39;</span><span class="p">},</span>
  <span class="k">for</span> <span class="nx">name</span> <span class="k">in</span> <span class="nx">names</span>
    <span class="nx">li</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;friend&#39;</span><span class="p">},</span> <span class="p">[</span><span class="nx">name</span><span class="p">]</span>

<span class="c1"># Or equivalently:</span>

<span class="nx">ul</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;friends&#39;</span><span class="p">},</span> <span class="nx">names</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(name) -&gt;</span>
  <span class="nx">li</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;friend&#39;</span><span class="p">},</span> <span class="p">[</span><span class="nx">name</span><span class="p">]</span>

<span class="c1"># Conditionals:</span>

<span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;profile&#39;</span><span class="p">},</span> <span class="p">[</span>
  <span class="nx">img</span> <span class="p">{</span><span class="nv">src: </span><span class="s">&quot;</span><span class="si">#{</span><span class="nx">user</span><span class="p">.</span><span class="nx">picUrl</span><span class="si">}</span><span class="s">&quot;</span><span class="p">},</span> <span class="p">[]</span>
  <span class="k">if</span> <span class="nx">signedIn</span>
    <span class="nx">button</span> <span class="p">{},</span> <span class="p">[</span><span class="s">&quot;Add </span><span class="si">#{</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="si">}</span><span class="s">&quot;</span> <span class="nx">as</span> <span class="nx">a</span> <span class="nx">friend</span><span class="p">.</span><span class="s">&quot;]</span>
<span class="s">  else</span>
<span class="s">    p {}, [&quot;</span><span class="nx">Sign</span> <span class="nx">up</span> <span class="nx">to</span> <span class="nx">connect</span> <span class="nx">with</span> <span class="c1">#{user.name}!&quot;]</span>
<span class="p">]</span>
</pre></div>

<p>Side note: for loops, it&#39;s generally better to prefer using <code>.map()</code>, since
it&#39;s the same interface for both <code>Array</code> and <code>rx.array</code>, and it also
creates a unique binding for the element, avoiding a <a href="http://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example">common pitfall</a> with
JavaScript/CoffeeScript loops and closures (you can also use CoffeeScript&#39;s
handy <code>do</code> keyword).</p>
<p>So far we&#39;ve been feeding full explicit arguments to each tag.  They are
actually more flexible in what they take.  We can clean up a bunch of the
syntactic noise in the last example by replacing <code>[&#39;string&#39;]</code> with just
<code>&#39;string&#39;</code>, and omitting empty arguments like <code>{}</code> and <code>[]</code> (the remaining
argument is treated as the attributes or the contents based on its type):</p>
<div class="highlight"><pre><span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;profile&#39;</span><span class="p">},</span> <span class="p">[</span>
  <span class="nx">img</span> <span class="p">{</span><span class="nv">src: </span><span class="s">&quot;</span><span class="si">#{</span><span class="nx">user</span><span class="p">.</span><span class="nx">picUrl</span><span class="si">}</span><span class="s">&quot;</span><span class="p">}</span>
  <span class="k">if</span> <span class="nx">signedIn</span>
    <span class="nx">button</span> <span class="s">&quot;Add </span><span class="si">#{</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="si">}</span><span class="s">&quot;</span> <span class="nx">as</span> <span class="nx">a</span> <span class="nx">friend</span><span class="p">.</span><span class="s">&quot;</span>
<span class="s">  else</span>
<span class="s">    p &quot;</span><span class="nx">Sign</span> <span class="nx">up</span> <span class="nx">to</span> <span class="nx">connect</span> <span class="nx">with</span> <span class="c1">#{user.name}!&quot;</span>
<span class="p">]</span>
</pre></div>

<p>Tags are really just functions that return DOM elements (wrapped in jQuery
objects), so you are free to attach behaviors to them:</p>
<div class="highlight"><pre><span class="nv">$button = </span><span class="nx">button</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;submit-btn&#39;</span><span class="p">},</span> <span class="s">&#39;Click Me!&#39;</span>
<span class="nx">$button</span><span class="p">.</span><span class="nx">click</span> <span class="nf">-&gt;</span> <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">text</span><span class="p">(</span><span class="s">&#39;I been clicked.&#39;</span><span class="p">)</span>
</pre></div>

<p>However, since often times you may be working with deeply nested templates
structures where it&#39;s clumsy to tack on behaviors afterward, you can for
convenience supply a function in an attribute named <code>init</code>, which is
immediately invoked with the current element bound to <code>this</code>:</p>
<div class="highlight"><pre><span class="nx">table</span> <span class="p">{},</span> <span class="nx">properties</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(prop) -&gt;</span>
  <span class="nx">tr</span> <span class="p">[</span>
    <span class="nx">td</span> <span class="nx">prop</span><span class="p">.</span><span class="nx">name</span>
    <span class="nx">td</span> <span class="p">[</span>
      <span class="nx">input</span> <span class="p">{</span>
        <span class="nv">type: </span><span class="s">&#39;text&#39;</span>
        <span class="nv">value: </span><span class="nx">prop</span><span class="p">.</span><span class="nx">value</span>
        <span class="nv">placeholder: </span><span class="s">&#39;Enter property value&#39;</span>
        <span class="nv">init: </span><span class="nf">-&gt;</span> <span class="nx">@blur</span> <span class="o">=&gt;</span> <span class="nx">setProperty</span><span class="p">(</span><span class="nx">prop</span><span class="p">,</span> <span class="nx">@val</span><span class="p">())</span>
      <span class="p">}</span>
    <span class="p">]</span>
  <span class="p">]</span>
</pre></div>

<p>Since CoffeeScript assignments are expressions and it automatically manages
variable scoping, we also have a convenient way of naming elements
anywhere in a template structure:</p>
<div class="highlight"><pre><span class="nx">table</span> <span class="p">{},</span> <span class="nx">properties</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(prop) -&gt;</span>
  <span class="nv">$row = </span><span class="nx">tr</span> <span class="p">[</span>
    <span class="nx">td</span> <span class="nx">prop</span><span class="p">.</span><span class="nx">name</span>
    <span class="nx">td</span> <span class="p">[</span>
      <span class="nx">input</span> <span class="p">{</span>
        <span class="nv">type: </span><span class="s">&#39;text&#39;</span>
        <span class="nv">value: </span><span class="nx">prop</span><span class="p">.</span><span class="nx">value</span>
        <span class="nv">placeholder: </span><span class="s">&#39;Enter property value&#39;</span>
        <span class="nv">init: </span><span class="nf">-&gt;</span> <span class="nx">@blur</span> <span class="o">=&gt;</span>
          <span class="nx">$row</span><span class="p">.</span><span class="nx">css</span><span class="p">(</span><span class="s">&#39;opacity&#39;</span><span class="p">,</span> <span class="p">.</span><span class="mi">5</span><span class="p">)</span>
          <span class="nx">setProperty</span><span class="p">(</span><span class="nx">prop</span><span class="p">,</span> <span class="nx">@val</span><span class="p">())</span>
      <span class="p">}</span>
    <span class="p">]</span>
  <span class="p">]</span>
</pre></div>

<p><code>init</code> was an example of a <em>special attribute</em>.  These are just attributes
that are intercepted and handled differently from others, which are simply
passed on as regular HTML attributes on the DOM element.  Besides <code>init</code>,
built-in special attributes include:</p>
<ul>
<li><p><code>style</code>, which in addition to regular style strings accepts jQuery-style
mappings like <code>{fontSize: 10}</code>, so you can write:</p>
<div class="highlight"><pre><span class="nx">div</span> <span class="p">{</span>
  <span class="nv">style: </span><span class="nx">bind</span> <span class="nf">-&gt;</span>
    <span class="nv">width: </span><span class="nx">score</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
    <span class="nv">color: </span><span class="k">if</span> <span class="nx">team</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;a&#39;</span> <span class="k">then</span> <span class="s">&#39;red&#39;</span> <span class="k">else</span> <span class="s">&#39;blue&#39;</span>
    <span class="nv">display: </span><span class="s">&#39;none&#39;</span> <span class="k">if</span> <span class="nx">gameMode</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&#39;running&#39;</span>
<span class="p">}</span>
</pre></div>

</li>
<li><p><code>class</code>, which in addition to regular class strings accepts an array of
class names (filtering out <code>undefined</code>), e.g.:</p>
<div class="highlight"><pre><span class="nx">button</span> <span class="p">{</span>
  <span class="k">class</span><span class="o">:</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="p">[</span>
    <span class="s">&#39;btn&#39;</span>
    <span class="s">&#39;btn-primary&#39;</span> <span class="k">if</span> <span class="nx">formComplete</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
  <span class="p">]</span>
<span class="p">}</span>
</pre></div>

<p>(You can also access this transform directly via <code>rxt.smushClasses</code>.)</p>
</li>
<li><p>and all jQuery events: <code>click</code>, <code>focus</code>, <code>mouseleave</code>, <code>keyup</code>, <code>load</code>,
etc.  So we could have bound the blur event in the earlier example
directly (note it also takes a jQuery object as <code>this</code>):</p>
<div class="highlight"><pre><span class="p">...</span>
      <span class="nx">input</span> <span class="p">{</span>
        <span class="nv">type: </span><span class="s">&#39;text&#39;</span>
        <span class="nv">value: </span><span class="nx">prop</span><span class="p">.</span><span class="nx">value</span>
        <span class="nv">placeholder: </span><span class="s">&#39;Enter property value&#39;</span>
        <span class="nv">blur: </span><span class="nf">-&gt;</span>
          <span class="nx">$row</span><span class="p">.</span><span class="nx">css</span><span class="p">(</span><span class="s">&#39;opacity&#39;</span><span class="p">,</span> <span class="p">.</span><span class="mi">5</span><span class="p">)</span>
          <span class="nx">setProperty</span><span class="p">(</span><span class="nx">prop</span><span class="p">,</span> <span class="nx">@val</span><span class="p">())</span>
      <span class="p">}</span>
<span class="p">...</span>
</pre></div>

</li>
</ul>
<p>You can also add your own special attribute by inserting a function into
the <code>specialAttrs</code> global structure.</p>
<h2 id="reactive-templates"><a name="reactive-templates">Reactive Templates</a></h2>
<p>Reactive templates tie together the UI-building style from the previous section
with the reactive programming primitives from earlier.</p>
<p>Now, you <em>could</em> just write explicit imperative code to transform the DOM
in a way that consistently reflects the bindings you&#39;re interested in.
For instance:</p>
<div class="highlight"><pre><span class="nx">$</span><span class="p">(</span><span class="s">&#39;body&#39;</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="nx">input</span> <span class="p">{</span>
  <span class="k">class</span><span class="o">:</span> <span class="s">&#39;name passive&#39;</span>
  <span class="nv">type: </span><span class="s">&#39;text&#39;</span>
  <span class="nv">placeholder: </span><span class="s">&#39;Name&#39;</span>
  <span class="nv">value: </span><span class="s">&#39;&#39;</span>
<span class="p">})</span>
<span class="nx">displayName</span><span class="p">.</span><span class="nx">onSet</span><span class="p">.</span><span class="nx">sub</span> <span class="nf">([oldVal, newVal]) -&gt;</span>
  <span class="nx">$</span><span class="p">(</span><span class="s">&#39;.name&#39;</span><span class="p">).</span><span class="nx">val</span><span class="p">(</span><span class="nx">newVal</span><span class="p">)</span>
<span class="nx">isActive</span><span class="p">.</span><span class="nx">onSet</span><span class="p">.</span><span class="nx">sub</span> <span class="nf">([oldVal, newVal]) -&gt;</span>
  <span class="k">if</span> <span class="nx">newVal</span>
    <span class="nx">$</span><span class="p">(</span><span class="s">&#39;.name&#39;</span><span class="p">).</span><span class="nx">removeClass</span><span class="p">(</span><span class="s">&#39;passive&#39;</span><span class="p">).</span><span class="nx">addClass</span><span class="p">(</span><span class="s">&#39;active&#39;</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="nx">$</span><span class="p">(</span><span class="s">&#39;.name&#39;</span><span class="p">).</span><span class="nx">removeClass</span><span class="p">(</span><span class="s">&#39;active&#39;</span><span class="p">).</span><span class="nx">addClass</span><span class="p">(</span><span class="s">&#39;passive&#39;</span><span class="p">)</span>
</pre></div>

<p>However, more complex transformations can become more involved.</p>
<div class="highlight"><pre><span class="nv">names = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">array</span><span class="p">([</span><span class="s">&#39;1&#39;</span><span class="p">,</span><span class="s">&#39;2&#39;</span><span class="p">,</span><span class="s">&#39;3&#39;</span><span class="p">,</span><span class="s">&#39;4&#39;</span><span class="p">,</span><span class="s">&#39;5&#39;</span><span class="p">])</span>
<span class="nx">$</span><span class="p">(</span><span class="s">&#39;body&#39;</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="nv">$nameList = </span><span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;name-list&#39;</span><span class="p">})</span>
<span class="nv">spans = </span><span class="nx">names</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(name) -&gt;</span> <span class="nx">span</span> <span class="nx">name</span>
<span class="nx">spans</span><span class="p">.</span><span class="nx">onChange</span><span class="p">.</span><span class="nx">sub</span> <span class="nf">([index, added, removed]) -&gt;</span>
  <span class="c1"># Homework: fill in logic here for efficiently inserting/removing DOM</span>
  <span class="c1"># nodes!</span>
</pre></div>

<p>You also shouldn&#39;t have to repeatedly code this logic any time you want to make
bindings, and it would be much more clear to specify the template
declaratively:</p>
<div class="highlight"><pre><span class="nx">$</span><span class="p">(</span><span class="s">&#39;body&#39;</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span>
  <span class="nx">input</span> <span class="p">{</span>
    <span class="k">class</span><span class="o">:</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="s">&quot;name </span><span class="si">#{</span><span class="k">if</span> <span class="nx">isActive</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="k">then</span> <span class="s">&#39;active&#39;</span> <span class="k">else</span> <span class="s">&#39;passive&#39;</span><span class="si">}</span><span class="s">&quot;</span>
    <span class="nv">type: </span><span class="s">&#39;text&#39;</span>
    <span class="nv">placeholder: </span><span class="s">&#39;Name&#39;</span>
    <span class="nv">value: </span><span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">displayName</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">)</span>

<span class="nx">$</span><span class="p">(</span><span class="s">&#39;body&#39;</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span>
  <span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;name-list&#39;</span><span class="p">},</span> <span class="nx">names</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(name) -&gt;</span>
    <span class="nx">span</span> <span class="nx">name</span>
<span class="p">)</span>
</pre></div>

<p>You&#39;re declaring what the UI should <em>always look like over time</em>, and the
system frees you from the responsibility of maintaining this.</p>
<p>Here&#39;s another quick example, this one of a todo list.  Notice how here we are
using a raw array in a cell, rather than an <code>rx.array</code>.  This is fine but not
as efficient in the face of large arrays.</p>
<div class="highlight"><pre><span class="nv">tasks = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">([</span><span class="s">&#39;Get milk&#39;</span><span class="p">,</span> <span class="s">&#39;Take out trash&#39;</span><span class="p">,</span> <span class="s">&#39;Clean up room&#39;</span><span class="p">])</span>
<span class="nx">$</span><span class="p">(</span><span class="s">&#39;body&#39;</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span>
  <span class="nx">ul</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;tasks&#39;</span><span class="p">},</span> <span class="nx">bind</span> <span class="nf">-&gt;</span>
    <span class="k">for</span> <span class="nx">task</span> <span class="k">in</span> <span class="nx">tasks</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
      <span class="nx">li</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;task&#39;</span><span class="p">},</span> <span class="s">&quot;User: </span><span class="si">#{</span><span class="nx">task</span><span class="si">}</span><span class="s">&quot;</span>
<span class="p">)</span>
</pre></div>

<p>Any attribute can be a cell:</p>
<div class="highlight"><pre><span class="nx">input</span> <span class="p">{</span><span class="nv">value: </span><span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">displayName</span><span class="p">.</span><span class="nx">get</span><span class="p">()}</span>
</pre></div>

<p>Contents can be a cell that returns an array (of strings or elements):</p>
<div class="highlight"><pre><span class="nx">span</span> <span class="p">{},</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="p">[</span><span class="nx">displayName</span><span class="p">.</span><span class="nx">get</span><span class="p">()]</span>
<span class="nx">div</span> <span class="p">{},</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">names</span><span class="p">.</span><span class="nx">all</span><span class="p">()</span>

<span class="c1"># shorthand:</span>
<span class="nx">span</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">displayName</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
<span class="nx">div</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">names</span><span class="p">.</span><span class="nx">all</span><span class="p">()</span>
</pre></div>

<p>or an observable array:</p>
<div class="highlight"><pre><span class="nx">div</span> <span class="p">{},</span> <span class="nx">names</span>
<span class="c1"># results in: &lt;div&gt;01234&lt;/div&gt;</span>

<span class="c1"># shorthand:</span>
<span class="nx">div</span> <span class="nx">names</span>

<span class="nx">div</span> <span class="p">{},</span> <span class="nx">names</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(name) -&gt;</span>
  <span class="nx">span</span> <span class="p">{},</span> <span class="p">[</span><span class="nx">name</span><span class="p">]</span>
<span class="c1"># results in: &lt;div&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;...&lt;/div&gt;</span>

<span class="c1"># shorthand:</span>
<span class="nx">div</span> <span class="nx">names</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(name) -&gt;</span>
  <span class="nx">span</span> <span class="nx">name</span>
</pre></div>

<p>You have very fine-grained control over the re-rendering process.  For
instance, say we had a model like the following:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nx">User</span>
  <span class="nv">constructor: </span><span class="nf">(id, name) -&gt;</span>
    <span class="vi">@id = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
    <span class="vi">@name = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>

<span class="k">class</span> <span class="nx">App</span>
  <span class="nv">constructor: </span><span class="nf">(users) -&gt;</span>
    <span class="vi">@users = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">array</span><span class="p">(</span><span class="nx">users</span><span class="p">)</span>

<span class="nv">app = </span><span class="k">new</span> <span class="nx">App</span><span class="p">([</span>
  <span class="k">new</span> <span class="nx">User</span><span class="p">(</span><span class="s">&#39;John&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">new</span> <span class="nx">User</span><span class="p">(</span><span class="s">&#39;Jane&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">])</span>
</pre></div>

<p>If we wanted to just re-render individual elements, we could do that with:</p>
<div class="highlight"><pre><span class="nx">select</span> <span class="nx">app</span><span class="p">.</span><span class="nx">users</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(user) -&gt;</span>
  <span class="nx">option</span> <span class="p">{</span><span class="nv">value: </span><span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">user</span><span class="p">.</span><span class="nx">id</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span><span class="si">}</span><span class="s">&quot;</span><span class="p">},</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span><span class="si">}</span><span class="s">&quot;</span>
</pre></div>

<p>On the other hand, if we wanted to re-render the entire section whenever
anything changed, we could do so with:</p>
<div class="highlight"><pre><span class="nx">select</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">app</span><span class="p">.</span><span class="nx">users</span><span class="p">.</span><span class="nx">all</span><span class="p">().</span><span class="nx">map</span> <span class="nf">(user) -&gt;</span>
  <span class="nx">option</span> <span class="p">{</span><span class="nv">value: </span><span class="s">&quot;</span><span class="si">#{</span><span class="nx">user</span><span class="p">.</span><span class="nx">id</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span><span class="si">}</span><span class="s">&quot;</span><span class="p">},</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span><span class="si">}</span><span class="s">&quot;</span>
</pre></div>

<div class="note">
<strong>Key Lesson</strong>:
Nested <code>bind</code>/<code>map</code> calls are insulated from outer calls,
re-rendering only what&#39;s necessary.
</div>

<p>As an escape hatch, to insulate some code <code>fn</code> from the
current bind context and <em>not</em> subscribe to any dependencies therein, you
can use <code>rx.snap(fn)</code>.  This is evaluated only once:</p>
<div class="highlight"><pre><span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;editor&#39;</span><span class="p">},</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="p">[</span>
  <span class="nx">input</span> <span class="p">{</span><span class="nv">type: </span><span class="s">&#39;text&#39;</span><span class="p">,</span> <span class="nv">value: </span><span class="nx">snap</span> <span class="nf">-&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">get</span><span class="p">()}</span>
<span class="p">]</span>
</pre></div>

<p>Without the <code>snap</code>, anytime <code>x</code> changes, the entire <code>div</code> would be
re-rendered, but with a <code>bind</code>, the text box&#39;s contents would be
re-rendered.  <code>snap</code> is the &quot;anti-<code>bind</code>&quot;.</p>
<p>Sometimes you will want to append an observable array after some element.
Or you may want to make one element among a set conditionally rendered.
For these situations, there&#39;s a handy <code>rx.flatten</code> utility function:</p>
<div class="highlight"><pre><span class="nx">div</span> <span class="p">{},</span> <span class="nx">rx</span><span class="p">.</span><span class="nx">flatten</span> <span class="p">[</span>
  <span class="nx">h1</span> <span class="p">{},</span> <span class="s">&#39;Header&#39;</span>
  <span class="nx">headerItems</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(item) -&gt;</span> <span class="p">...</span>
  <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">separator</span> <span class="k">if</span> <span class="nx">showSeparator</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
  <span class="nx">h1</span> <span class="p">{},</span> <span class="s">&#39;Footer&#39;</span>
  <span class="nx">footerItems</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(item) -&gt;</span> <span class="p">...</span>
<span class="p">]</span>
</pre></div>

<p>(These behaviors may be folded into core <code>rxt</code> behavior if it proves to be
a sensible default.)</p>
<h2 id="more-on-arrays-and-reactive-templates"><a name="more-on-arrays-and-reactive-templates">More on Arrays and Reactive Templates</a></h2>
<p>Arrays also support an <code>indexed</code> method which returns a copy of the array,
but which actually tracks the indices of its elements, such that when you
<code>map</code> the array, the mapper function is given the index (as a reactive
cell) in addition to the current element.  This way you can react to shifts
in the position of each element.</p>
<p>For instance, if you had a list where you wanted the rows to be styled
based on whether they&#39;re prime:</p>
<div class="highlight"><pre><span class="nv">xs = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">array</span><span class="p">(...)</span>
<span class="nx">ul</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">indexed</span><span class="p">().</span><span class="nx">map</span> <span class="nf">(x,i) -&gt;</span>
  <span class="nx">li</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="k">if</span> <span class="nx">isPrime</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">get</span><span class="p">())</span> <span class="k">then</span> <span class="s">&#39;prime&#39;</span> <span class="k">else</span> <span class="s">&#39;&#39;</span><span class="p">},</span> <span class="nx">x</span>
<span class="c1"># shifts the entire array, but still only prime rows have class &quot;prime&quot;</span>
<span class="nx">xs</span><span class="p">.</span><span class="nx">removeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>

<p>This is not built into <code>map</code> since it would make <code>map</code>s more expensive, and
in general this is a less-frequently used feature.</p>
<h2 id="components"><a name="components">Components</a></h2>
<p>Making reusable components is as simple as defining a function, where the
convention is to pass in a single named argument object, as opposed to
regular arguments, since components have a tendency to demand a fairly
unwieldy set of parameters:</p>
<div class="highlight"><pre><span class="c1">#</span>
<span class="c1"># tabs: array of tab contents, where each tab content is itself an array of</span>
<span class="c1">#   elements or text</span>
<span class="c1"># initialTabIndex: index of initial tab; defaults to 0</span>
<span class="c1"># activeClass: class to set an active tab; defaults to &#39;active-tab&#39;</span>
<span class="c1"># change: a callback that is called whenever the active tab is changed,</span>
<span class="c1">#   and is passed the new active tab index</span>
<span class="c1">#</span>

<span class="nv">tabs = </span><span class="nf">(opts) -&gt;</span>
  <span class="nv">opts = </span><span class="nx">_</span><span class="p">(</span><span class="nx">opts</span><span class="p">).</span><span class="nx">defaults</span>
    <span class="nv">initialTabIndex: </span><span class="mi">0</span>
    <span class="nv">activeClass: </span><span class="s">&#39;active-tab&#39;</span>
    <span class="nv">change: </span><span class="nf">-&gt;</span>
  <span class="nv">opts = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">rxt</span><span class="p">.</span><span class="nx">cast</span> <span class="nx">opts</span><span class="p">,</span>
    <span class="nv">tabs: </span><span class="s">&#39;array&#39;</span>

  <span class="nv">activeTabIndex = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="nx">opts</span><span class="p">.</span><span class="nx">initialTabIndex</span><span class="p">)</span>

  <span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;tabs&#39;</span><span class="p">},</span> <span class="p">[</span>
    <span class="nx">ul</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;nav-tabs&#39;</span><span class="p">},</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">tabs</span><span class="p">.</span><span class="nx">map</span> <span class="nf">([tabName, tabContents], i) -&gt;</span>
      <span class="nx">li</span> <span class="p">{</span>
        <span class="k">class</span><span class="o">:</span> <span class="nx">bind</span> <span class="nf">-&gt;</span>
          <span class="p">[</span>
            <span class="s">&quot;nav-tab&quot;</span>
            <span class="s">&quot;</span><span class="si">#{</span><span class="k">if</span> <span class="nx">activeTabIndex</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="o">==</span> <span class="nx">i</span> <span class="k">then</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">activeClass</span> <span class="k">else</span> <span class="s">&#39;&#39;</span><span class="si">}</span><span class="s">&quot;</span>
          <span class="p">].</span><span class="nx">join</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)</span>
        <span class="nv">click: </span><span class="nf">-&gt;</span>
          <span class="nx">activeTabIndex</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
          <span class="nx">opts</span><span class="p">.</span><span class="nx">change</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
      <span class="p">},</span> <span class="p">[</span><span class="nx">tabName</span><span class="p">]</span>
    <span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;tab-content&#39;</span><span class="p">},</span> <span class="nx">bind</span> <span class="nf">-&gt;</span>
      <span class="p">[</span><span class="nx">tabName</span><span class="p">,</span> <span class="nx">tabContents</span><span class="p">]</span> <span class="o">=</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">tabs</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="nx">activeTabIndex</span><span class="p">.</span><span class="nx">get</span><span class="p">())</span>
      <span class="nx">tabContents</span>
  <span class="p">]</span>
</pre></div>

<p>Above, we used a convenience function <code>rxt.cast</code> which lets us cast inputs
to the desired observable data type (cell or array).</p>
<p>Now we can use this with:</p>
<div class="highlight"><pre><span class="nv">modifyTab = </span><span class="nf">-&gt;</span> <span class="p">[</span><span class="s">&#39;MODIFY&#39;</span><span class="p">]</span>
<span class="nv">createTab = </span><span class="nf">-&gt;</span> <span class="p">[</span><span class="s">&#39;CREATE&#39;</span><span class="p">]</span>
<span class="nv">stylesTab = </span><span class="nf">-&gt;</span> <span class="p">[</span><span class="s">&#39;STYLES&#39;</span><span class="p">]</span>

<span class="nx">tabs</span> <span class="p">{</span>
  <span class="nv">activeClass: </span><span class="s">&#39;my-active-tab&#39;</span>
  <span class="nv">tabs: </span><span class="nx">rx</span><span class="p">.</span><span class="nx">array</span><span class="p">([</span>
    <span class="p">[</span><span class="s">&#39;Properties&#39;</span><span class="p">,</span> <span class="nx">modifyTab</span><span class="p">()]</span>
    <span class="p">[</span><span class="s">&#39;Create&#39;</span><span class="p">,</span> <span class="nx">createTab</span><span class="p">()]</span>
    <span class="p">[</span><span class="s">&#39;Styles&#39;</span><span class="p">,</span> <span class="nx">stylesTab</span><span class="p">()]</span>
  <span class="p">])</span>
<span class="p">}</span>
</pre></div>

<p>When defining abstractions, it&#39;s almost always better to err on the side of
making everything dynamic, since you can always opt-out of dynamism by stopping
propagation (e.g. with <code>snap</code> or with hoisting things out of a <code>bind</code>),
whereas you cannot later reintroduce dynamism into places with no dynamic
bindings.</p>
<h2 id="binding-to-dom-element-attributes"><a name="binding-to-dom-element-attributes">Binding To DOM Element Attributes</a></h2>
<p>We can treat certain interactive DOM elements&#39; attributes as cells, thus
binding to them as well.</p>
<p>Consider a type-ahead search component, where the completion list only displays
items that prefix-match the given query.  Furthermore, we want the completion
list to only show up if it&#39;s enabled by the checkbox and when we actually have
focused on the input text field:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nx">Doc</span>
  <span class="nv">constructor: </span><span class="nf">(@title, @url) -&gt;</span>

<span class="nv">docs = </span><span class="p">[</span>
  <span class="k">new</span> <span class="nx">Doc</span><span class="p">(</span><span class="s">&#39;An axiomatic basis for computer programming&#39;</span><span class="p">,</span> <span class="s">&#39;http://sigpl.or.kr/school/2005w/slides/2_17_1.pdf&#39;</span><span class="p">)</span>
  <span class="k">new</span> <span class="nx">Doc</span><span class="p">(</span><span class="s">&#39;The next 700 programming languages&#39;</span><span class="p">,</span> <span class="s">&#39;http://www.thecorememory.com/Next_700.pdf&#39;</span><span class="p">)</span>
  <span class="k">new</span> <span class="nx">Doc</span><span class="p">(</span><span class="s">&#39;A theory of type polymorphism in programming&#39;</span><span class="p">,</span> <span class="s">&#39;http://courses.engr.illinois.edu/cs421/sp2012/project/milner-polymorphism.pdf&#39;</span><span class="p">)</span>
  <span class="k">new</span> <span class="nx">Doc</span><span class="p">(</span><span class="s">&#39;A semantics of multiple inheritance&#39;</span><span class="p">,</span> <span class="s">&#39;http://lucacardelli.name/Papers/Inheritance.pdf&#39;</span><span class="p">)</span>
<span class="p">]</span>

<span class="nx">$</span><span class="p">(</span><span class="s">&#39;body&#39;</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span>
  <span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;search&#39;</span><span class="p">},</span> <span class="p">[</span>
    <span class="nv">$query = </span><span class="nx">input</span> <span class="p">{</span><span class="nv">type: </span><span class="s">&#39;text&#39;</span><span class="p">,</span> <span class="nv">placeholder: </span><span class="s">&#39;Enter query&#39;</span><span class="p">}</span>
    <span class="nv">$showResults = </span><span class="nx">input</span> <span class="p">{</span><span class="nv">type: </span><span class="s">&#39;checkbox&#39;</span><span class="p">,</span> <span class="nv">id: </span><span class="s">&#39;show-results&#39;</span><span class="p">}</span>
    <span class="nx">label</span> <span class="p">{</span><span class="k">for</span><span class="o">:</span> <span class="s">&#39;show-results&#39;</span><span class="p">},</span> <span class="s">&#39;Show type-ahead results&#39;</span>
    <span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;results&#39;</span><span class="p">},</span> <span class="nx">bind</span> <span class="nf">-&gt;</span>
      <span class="nv">focused = </span><span class="nx">$query</span><span class="p">.</span><span class="nx">rx</span><span class="p">(</span><span class="s">&#39;focused&#39;</span><span class="p">)</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="s">&#39;firing&#39;</span><span class="p">,</span> <span class="nx">focused</span>
      <span class="k">if</span> <span class="nx">focused</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="o">and</span> <span class="nx">$showResults</span><span class="p">.</span><span class="nx">rx</span><span class="p">(</span><span class="s">&#39;checked&#39;</span><span class="p">).</span><span class="nx">get</span><span class="p">()</span>
        <span class="k">for</span> <span class="nx">doc</span> <span class="k">in</span> <span class="nx">docs</span> <span class="k">when</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">title</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">$query</span><span class="p">.</span><span class="nx">rx</span><span class="p">(</span><span class="s">&#39;val&#39;</span><span class="p">).</span><span class="nx">get</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="mi">0</span>
          <span class="nx">div</span> <span class="p">[</span>
            <span class="nx">a</span> <span class="p">{</span><span class="nv">href: </span><span class="nx">doc</span><span class="p">.</span><span class="nx">url</span><span class="p">},</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">title</span>
          <span class="p">]</span>
      <span class="k">else</span>
        <span class="p">[]</span>
  <span class="p">]</span>
<span class="p">)</span>
</pre></div>

<p>We are using three different types of reactive element attributes.
<code>rx(property)</code> returns the value of the given property (<code>focused</code>,
<code>checked</code>, <code>val</code>) as a cell.</p>
<h2 id="lifting"><a name="lifting">Lifting</a></h2>
<p>Often times your models will consist of objects or instances with various observable fields.  For instance, consider the <code>User</code> class defined earlier:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nx">User</span>
  <span class="nv">constructor: </span><span class="nf">(id, name) -&gt;</span>
    <span class="vi">@id = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
    <span class="vi">@name = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
</pre></div>

<p>You can alternatively take advantage of the dynamic runtime and use the
meta-facility <code>rx.lift</code> to convert a plain old Javascript object containing
non-observable fields to one with observable fields:</p>
<div class="highlight"><pre><span class="nv">x = </span><span class="p">{</span><span class="nx">a</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span><span class="p">[],</span> <span class="nx">c</span><span class="o">:</span><span class="p">{},</span> <span class="nx">d</span><span class="o">:</span><span class="kc">null</span><span class="p">}</span>
<span class="nx">rx</span><span class="p">.</span><span class="nx">lift</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1"># also returns x</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="c1"># 0</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">all</span><span class="p">()</span> <span class="c1"># []</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">c</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="c1"># {}</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">d</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="c1"># null</span>
</pre></div>

<p>It also makes writing <code>User</code> above simpler:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nx">User</span>
  <span class="nv">constructor: </span><span class="nf">(@id, @name) -&gt;</span> <span class="nx">rx</span><span class="p">.</span><span class="nx">lift</span><span class="p">(</span><span class="nx">@</span><span class="p">)</span>
<span class="k">new</span> <span class="nx">User</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#39;Joe&#39;</span><span class="p">).</span><span class="nx">name</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="c1"># Joe</span>
</pre></div>

<p>By default, fields that are arrays are turned into <code>rx.array</code>, while others
are turned into <code>rx.cell</code>.  You can control/refine how fields are lifted by
passing in a spec (by default, uses <code>rx.liftSpec</code> to generate one).  See
the <a href="api.html">API documentation</a> for more details.</p>
<h2 id="anti-pattern-non-nesting"><a name="anti-pattern--non-nesting">Anti-Pattern: Non-Nesting</a></h2>
<p>Do not construct UIs &quot;out-of-band&quot; from the <code>bind</code> hierarchy:</p>
<div class="highlight"><pre><span class="nv">namedisp = </span><span class="nx">span</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;name&#39;</span><span class="p">},</span> <span class="nx">username</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
<span class="nv">popup = </span><span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;modal&#39;</span><span class="p">},</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">namedisp</span>
</pre></div>

<p>The above will either</p>
<ul>
<li>fail to ever update <code>namedisp</code>, assuming there is no outer bind
running this code, or</li>
<li>cause any outer bind running this code (not shown) to re-evaluate
(likely unintended).</li>
</ul>
<p>This doesn&#39;t mean you always need to syntactically nest your code in the
following way:</p>
<div class="highlight"><pre><span class="nv">popup =</span>
  <span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;modal&#39;</span><span class="p">},</span> <span class="nx">bind</span> <span class="nf">-&gt;</span>
    <span class="nx">span</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;name&#39;</span><span class="p">},</span> <span class="nx">username</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
</pre></div>

<p>Instead, you can maintain the original structure of the code, but just
defer running the code until you&#39;re inside the bind, using functions:</p>
<div class="highlight"><pre><span class="nv">namedisp = </span><span class="nf">-&gt;</span> <span class="nx">span</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;name&#39;</span><span class="p">},</span> <span class="nx">username</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
<span class="nv">popup = </span><span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;modal&#39;</span><span class="p">},</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">namedisp</span><span class="p">()</span>
</pre></div>

<h2 id="next-steps"><a name="next-steps">Next Steps</a></h2>
<p>Congrats on making it all the way through the basic tutorial!  You can
continue to learn more about <a href="advanced.html">&quot;advanced&quot; concepts</a> (really just
more details), or read more on the <a href="design.html">motivation/design rationale</a>
behind the library.</p>
<p>Otherwise, go forth and build some web apps using Bobtail!  <a href="https://groups.google.com/forum/?fromgroups#!forum/reactive-coffee">Drop us a
line</a> if you do and would like to share your work on the website.</p>

        </section>
      </div>
    </div><!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41900480-1', 'yang.github.io');
      ga('send', 'pageview');
    </script>
    <footer>
      <div class="inner"><p>Copyright 2017 Bobtail/Reactive Coffee Authors.<br>Code licensed under <a href="https://github.com/inferinc/bobtail/blob/master/LICENSE">MIT License</a>.  Documentation licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.<br>Website design based on Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>

      </div>
    </footer>
  </body>
</html>
