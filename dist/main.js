// Generated by CoffeeScript 1.12.6
(function() {
  var rxFactory,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  rxFactory = function(rx, _, $) {
    var RawHtml, _input, ev, events, fn1, input, j, len, mktag, normalizeTagArgs, prepContents, prop, propSet, props, radio, rxt, setDynProp, setProp, specialAttrs, svg_events, svg_tags, swapChecked, tag, tags, toNodes, updateContents, updateSVGContents;
    $.fn.rx = function(prop) {
      var checked, focused, map, val;
      map = this.data('rx-map');
      if (map == null) {
        this.data('rx-map', map = Object.create(null));
      }
      if (prop in map) {
        return map[prop];
      }
      return map[prop] = (function() {
        switch (prop) {
          case 'focused':
            focused = rx.cell(this.is(':focus'));
            this.focus(function() {
              return focused.set(true);
            });
            this.blur(function() {
              return focused.set(false);
            });
            return focused;
          case 'val':
            val = rx.cell(this.val());
            this.change((function(_this) {
              return function() {
                return val.set(_this.val());
              };
            })(this));
            this.on('input', (function(_this) {
              return function() {
                return val.set(_this.val());
              };
            })(this));
            return val;
          case 'checked':
            checked = rx.cell(this.is(':checked'));
            this.change((function(_this) {
              return function() {
                return checked.set(_this.is(':checked'));
              };
            })(this));
            return checked;
          default:
            throw new Error('Unknown reactive property type');
        }
      }).call(this);
    };
    rxt = {};
    prepContents = function(contents) {
      if (contents instanceof rx.ObsCell || contents instanceof rx.ObsArray || _.isArray(contents)) {
        contents = rx.flatten(contents);
      }
      return contents;
    };
    rxt.events = {};
    rxt.events.enabled = false;
    rxt.events.onElementChildrenChanged = new rx.Ev();
    rxt.events.onElementAttrsChanged = new rx.Ev();
    RawHtml = rxt.RawHtml = (function() {
      function RawHtml(html1) {
        this.html = html1;
      }

      return RawHtml;

    })();
    events = ["blur", "change", "click", "dblclick", "error", "focus", "focusin", "focusout", "hover", "keydown", "keypress", "keyup", "load", "mousedown", "mouseenter", "mouseleave", "mousemove", "mouseout", "mouseover", "mouseup", "ready", "resize", "scroll", "select", "submit", "toggle", "unload"];
    svg_events = ["click"];
    specialAttrs = rxt.specialAttrs = {
      init: function(elt, fn) {
        return fn.call(elt);
      }
    };
    fn1 = function(ev) {
      return specialAttrs[ev] = function(elt, fn) {
        if (elt instanceof SVGElement && indexOf.call(svg_events, ev) >= 0) {
          return elt.addEventListener(ev, fn);
        } else {
          return elt[ev](function(e) {
            return fn.call(elt, e);
          });
        }
      };
    };
    for (j = 0, len = events.length; j < len; j++) {
      ev = events[j];
      fn1(ev);
    }
    props = ['async', 'autofocus', 'checked', 'location', 'multiple', 'readOnly', 'selected', 'selectedIndex', 'tagName', 'nodeName', 'nodeType', 'ownerDocument', 'defaultChecked', 'defaultSelected'];
    propSet = _.object((function() {
      var l, len1, results;
      results = [];
      for (l = 0, len1 = props.length; l < len1; l++) {
        prop = props[l];
        results.push([prop, null]);
      }
      return results;
    })());
    setProp = function(elt, prop, val) {
      if (elt instanceof SVGElement) {
        return elt.setAttribute(prop, val);
      } else if (prop === 'value') {
        return elt.val(val);
      } else if (prop in propSet) {
        return elt.prop(prop, val);
      } else {
        return elt.attr(prop, val);
      }
    };
    setDynProp = function(elt, prop, val, xform) {
      if (xform == null) {
        xform = _.identity;
      }
      if (val instanceof rx.ObsCell) {
        return rx.autoSub(val.onSet, function(arg) {
          var n, o;
          o = arg[0], n = arg[1];
          setProp(elt, prop, xform(n));
          if (rxt.events.enabled) {
            return rxt.events.onElementAttrsChanged.pub({
              $element: elt,
              attr: prop
            });
          }
        });
      } else {
        return setProp(elt, prop, xform(val));
      }
    };
    normalizeTagArgs = function(arg1, arg2) {
      if ((arg1 == null) && (arg2 == null)) {
        return [{}, null];
      } else if (arg1 instanceof Object && (arg2 != null)) {
        return [arg1, arg2];
      } else if ((arg2 == null) && _.isString(arg1) || _.isNumber(arg1) || arg1 instanceof Element || arg1 instanceof SVGElement || arg1 instanceof RawHtml || arg1 instanceof $ || _.isArray(arg1) || arg1 instanceof rx.ObsCell || arg1 instanceof rx.ObsArray || arg1 instanceof rx.ObsSet) {
        return [{}, arg1];
      } else {
        return [arg1, null];
      }
    };
    toNodes = function(contents) {
      var child, l, len1, parsed, results;
      results = [];
      for (l = 0, len1 = contents.length; l < len1; l++) {
        child = contents[l];
        if (child != null) {
          if (_.isString(child) || _.isNumber(child)) {
            results.push(document.createTextNode(child));
          } else if (child instanceof Element || child instanceof SVGElement) {
            results.push(child);
          } else if (child instanceof RawHtml) {
            parsed = $(child.html);
            if (parsed.length !== 1) {
              throw new Error('RawHtml must wrap a single element');
            }
            results.push(parsed[0]);
          } else if (child instanceof $) {
            if (child.length !== 1) {
              throw new Error('jQuery object must wrap a single element');
            }
            results.push(child[0]);
          } else {
            throw new Error("Unknown element type in array: " + child.constructor.name + " (must be string, number, Element, RawHtml, or jQuery objects)");
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    updateContents = function(elt, contents) {
      var covers, hasWidth, left, node, nodes, top;
      if (elt.html) {
        elt.html('');
      }
      if (contents == null) {

      } else if (_.isArray(contents)) {
        nodes = toNodes(contents);
        elt.append(nodes);
        if (false) {
          hasWidth = function(node) {
            var e;
            try {
              return ($(node).width() != null) !== 0;
            } catch (error) {
              e = error;
              return false;
            }
          };
          covers = (function() {
            var l, len1, ref, ref1, results;
            ref = nodes != null ? nodes : [];
            results = [];
            for (l = 0, len1 = ref.length; l < len1; l++) {
              node = ref[l];
              if (!(hasWidth(node))) {
                continue;
              }
              ref1 = $(node).offset(), left = ref1.left, top = ref1.top;
              results.push($('<div/>').appendTo($('body').first()).addClass('updated-element').offset({
                top: top,
                left: left
              }).width($(node).width()).height($(node).height()));
            }
            return results;
          })();
          setTimeout((function() {
            var cover, l, len1, results;
            results = [];
            for (l = 0, len1 = covers.length; l < len1; l++) {
              cover = covers[l];
              results.push($(cover).remove());
            }
            return results;
          }), 2000);
        }
        return nodes;
      } else if (_.isString(contents) || _.isNumber(contents) || contents instanceof Element || contents instanceof SVGElement || contents instanceof RawHtml || contents instanceof $) {
        return updateContents(elt, [contents]);
      } else {
        throw new Error("Unknown type for element contents: " + contents.constructor.name + " (accepted types: string, number, Element, RawHtml, jQuery object of single element, or array of the aforementioned)");
      }
    };
    rxt.mktag = mktag = function(tag) {
      return function(arg1, arg2) {
        var attrs, contents, elt, key, name, ref, ref1, value;
        ref = normalizeTagArgs(arg1, arg2), attrs = ref[0], contents = ref[1];
        contents = prepContents(contents);
        elt = $("<" + tag + "/>");
        ref1 = _.omit(attrs, _.keys(specialAttrs));
        for (name in ref1) {
          value = ref1[name];
          setDynProp(elt, name, value);
        }
        if (contents != null) {
          if (contents instanceof rx.ObsArray) {
            rx.autoSub(contents.indexed().onChangeCells, function(arg) {
              var added, cell, icell, index, l, len1, ref2, removed, results, toAdd;
              index = arg[0], removed = arg[1], added = arg[2];
              elt.contents().slice(index, index + removed.length).remove();
              toAdd = toNodes(added.map(function(arg3) {
                var cell, icell;
                cell = arg3[0], icell = arg3[1];
                return rx.snap(function() {
                  return cell.get();
                });
              }));
              if (index === elt.contents().length) {
                elt.append(toAdd);
              } else {
                elt.contents().eq(index).before(toAdd);
              }
              if (rxt.events.enabled && (removed.length || toAdd.length)) {
                rxt.events.onElementChildrenChanged.pub({
                  $element: elt,
                  type: "childrenUpdated",
                  added: toAdd,
                  removed: toNodes(removed.map(function(cell) {
                    return rx.snap(function() {
                      return cell.get();
                    });
                  }))
                });
              }
              results = [];
              for (l = 0, len1 = added.length; l < len1; l++) {
                ref2 = added[l], cell = ref2[0], icell = ref2[1];
                results.push((function(cell, icell) {
                  return rx.autoSub(cell.onSet, rx.skipFirst(function(arg3) {
                    var ival, old, val;
                    old = arg3[0], val = arg3[1];
                    ival = rx.snap(function() {
                      return icell.get();
                    });
                    toAdd = toNodes([val]);
                    elt.contents().eq(ival).replaceWith(toAdd);
                    if (rxt.events.enabled) {
                      return rxt.events.onElementChildrenChanged.pub({
                        $element: elt,
                        type: "childrenUpdated",
                        updated: toAdd
                      });
                    }
                  }));
                })(cell, icell));
              }
              return results;
            });
          } else {
            updateContents(elt, contents);
          }
        }
        for (key in attrs) {
          if (key in specialAttrs) {
            specialAttrs[key](elt, attrs[key], attrs, contents);
          }
        }
        return elt;
      };
    };
    tags = ['html', 'head', 'title', 'base', 'link', 'meta', 'style', 'script', 'noscript', 'body', 'body', 'section', 'nav', 'article', 'aside', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'h1', 'h6', 'header', 'footer', 'address', 'main', 'main', 'p', 'hr', 'pre', 'blockquote', 'ol', 'ul', 'li', 'dl', 'dt', 'dd', 'dd', 'figure', 'figcaption', 'div', 'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data', 'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark', 'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del', 'img', 'iframe', 'embed', 'object', 'param', 'object', 'video', 'audio', 'source', 'video', 'audio', 'track', 'video', 'audio', 'canvas', 'map', 'area', 'area', 'map', 'svg', 'math', 'table', 'caption', 'colgroup', 'col', 'tbody', 'thead', 'tfoot', 'tr', 'td', 'th', 'form', 'fieldset', 'legend', 'fieldset', 'label', 'input', 'button', 'select', 'datalist', 'optgroup', 'option', 'select', 'datalist', 'textarea', 'keygen', 'output', 'progress', 'meter', 'details', 'summary', 'details', 'menuitem', 'menu'];
    svg_tags = ['a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animate', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'color-profile', 'cursor', 'defs', 'desc', 'ellipse', 'feblend', 'fecolormatrix', 'fecomponenttransfer', 'fecomposite', 'feconvolvematrix', 'fediffuselighting', 'fedisplacementmap', 'fedistantlight', 'feflood', 'fefunca', 'fefuncb', 'fefuncg', 'fefuncr', 'fegaussianblur', 'feimage', 'femerge', 'femergenode', 'femorphology', 'feoffset', 'fepointlight', 'fespecularlighting', 'fespotlight', 'fetile', 'feturbulence', 'filter', 'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'missing-glyph', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'script', 'set', 'stop', 'style', 'svg', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'use', 'view', 'vkern'];
    updateSVGContents = function(elt, contents) {
      var l, len1, node, results, toAdd;
      while (elt.firstChild) {
        elt.removeChild(elt.firstChild);
      }
      if (_.isArray(contents)) {
        toAdd = toNodes(contents);
        results = [];
        for (l = 0, len1 = toAdd.length; l < len1; l++) {
          node = toAdd[l];
          results.push(elt.appendChild(node));
        }
        return results;
      } else if (_.isString(contents) || contents instanceof SVGElement) {
        return updateSVGContents(elt, [contents]);
      } else {
        console.error('updateSVGContents', elt, contents);
        throw "Must wrap contents " + contents + " as array or string";
      }
    };
    rxt.svg_mktag = mktag = function(tag) {
      return function(arg1, arg2) {
        var attrs, contents, elt, key, name, ref, ref1, value;
        ref = normalizeTagArgs(arg1, arg2), attrs = ref[0], contents = ref[1];
        elt = document.createElementNS('http://www.w3.org/2000/svg', tag);
        ref1 = _.omit(attrs, _.keys(specialAttrs));
        for (name in ref1) {
          value = ref1[name];
          setDynProp(elt, name, value);
        }
        if (contents != null) {
          if (contents instanceof rx.ObsArray) {
            contents.onChange.sub(function(arg) {
              var added, i, index, l, len1, len2, m, node, p, ref2, removed, results, results1, toAdd;
              index = arg[0], removed = arg[1], added = arg[2];
              for (i = l = 0, ref2 = removed.length; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
                elt.removeChild(elt.childNodes[index]);
              }
              toAdd = toNodes(added);
              if (index === elt.childNodes.length) {
                results = [];
                for (m = 0, len1 = toAdd.length; m < len1; m++) {
                  node = toAdd[m];
                  results.push(elt.appendChild(node));
                }
                return results;
              } else {
                results1 = [];
                for (p = 0, len2 = toAdd.length; p < len2; p++) {
                  node = toAdd[p];
                  results1.push(elt.childNodes[index].insertBefore(node));
                }
                return results1;
              }
            });
          } else if (contents instanceof rx.ObsCell) {
            contents.onSet.sub(function(arg) {
              var old, val;
              old = arg[0], val = arg[1];
              return updateSVGContents(elt, val);
            });
          } else {
            updateSVGContents(elt, contents);
          }
        }
        for (key in attrs) {
          if (key in specialAttrs) {
            specialAttrs[key](elt, attrs[key], attrs, contents);
          }
        }
        return elt;
      };
    };
    rxt.tags = _.object((function() {
      var l, len1, results;
      results = [];
      for (l = 0, len1 = tags.length; l < len1; l++) {
        tag = tags[l];
        results.push([tag, rxt.mktag(tag)]);
      }
      return results;
    })());
    input = rxt.tags.input;
    _input = function(type, opts) {
      return input(_.extend({
        type: type
      }, opts));
    };
    input.color = function(opts) {
      return _input('color', opts);
    };
    input.date = function(opts) {
      return _input('date', opts);
    };
    input.datetime = function(opts) {
      return _input('datetime', opts);
    };
    input.datetimeLocal = function(opts) {
      return _input('datetime-local', opts);
    };
    input.email = function(opts) {
      return _input('email', opts);
    };
    input.file = function(opts) {
      return _input('file', opts);
    };
    input.hidden = function(opts) {
      return _input('hidden', opts);
    };
    input.image = function(opts) {
      return _input('image', opts);
    };
    input.month = function(opts) {
      return _input('month', opts);
    };
    input.number = function(opts) {
      return _input('number', opts);
    };
    input.password = function(opts) {
      return _input('password', opts);
    };
    input.range = function(opts) {
      return _input('range', opts);
    };
    input.reset = function(opts) {
      return _input('reset', opts);
    };
    input.search = function(opts) {
      return _input('search', opts);
    };
    input.submit = function(opts) {
      return _input('submit', opts);
    };
    input.tel = function(opts) {
      return _input('tel', opts);
    };
    input.text = function(opts) {
      return _input('text', opts);
    };
    input.time = function(opts) {
      return _input('time', opts);
    };
    input.url = function(opts) {
      return _input('url', opts);
    };
    input.week = function(opts) {
      return _input('week', opts);
    };
    swapChecked = function($input) {

      /*
      Swaps $input.prop so that, whenever $input.prop("checked", ...) is called to set whether $input
      is checked, we also update the content of $input.rx("checked") with the same.
       */
      $input._oldProp = $input.prop;
      $input.prop = function() {
        var args, res;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        res = $input._oldProp.apply($input, args);
        if (args.length > 1 && args[0] === "checked") {
          $input.rx("checked").set($input.prop("checked"));
        }
        return res;
      };
      return $input;
    };
    input.checkbox = function(opts) {

      /*
      A checkbox with a default property `data-unchecked-value` of "false".  This is so that if you
      use $.serializeJSON() to read the value of this checkbox in a form, the value will be false
      if it is unchecked.
       */
      return swapChecked(input(_.extend({
        type: "checkbox"
      }, opts)));
    };
    input.radio = radio = function(opts) {
      return swapChecked(input(_.extend({
        type: "radio"
      }, opts)));
    };
    rxt.svg_tags = _.object((function() {
      var l, len1, results;
      results = [];
      for (l = 0, len1 = svg_tags.length; l < len1; l++) {
        tag = svg_tags[l];
        results.push([tag, rxt.svg_mktag(tag)]);
      }
      return results;
    })());
    rxt.rawHtml = function(html) {
      return new RawHtml(html);
    };
    rxt.specialChar = function(code, tag) {
      if (tag == null) {
        tag = 'span';
      }
      return rxt.rawHtml("<" + tag + ">&" + code + ";</" + tag + ">");
    };
    rxt.unicodeChar = function(code, tag) {
      if (tag == null) {
        tag = 'span';
      }
      return rxt.rawHtml("<" + tag + ">\\u" + code + ";</" + tag + ">");
    };
    rxt.importTags = (function(_this) {
      return function(x) {
        return _(x != null ? x : _this).extend(rxt.tags);
      };
    })(this);
    rxt.cast = function(value, type) {
      if (type == null) {
        type = "cell";
      }
      console.warn("Warning: rx.rxt.cast is deprecated. Use rx.cast instead.");
      return rx.cast(value, type);
    };
    rxt.trim = $.trim;
    rxt.dasherize = function(str) {
      return rxt.trim(str).replace(/([A-Z])/g, '-$1').replace(/[-_\s]+/g, '-').toLowerCase();
    };
    rxt.cssify = function(map) {
      var k, v;
      console.warn('cssify is deprecated; set the `style` property directly to a JSON object.');
      return ((function() {
        var results;
        results = [];
        for (k in map) {
          v = map[k];
          if (v != null) {
            results.push((rxt.dasherize(k)) + ": " + (_.isNumber(v) ? v + 'px' : v) + ";");
          }
        }
        return results;
      })()).join(' ');
    };
    specialAttrs.style = function(elt, value) {
      var isCell;
      isCell = value instanceof rx.ObsCell;
      return rx.autoSub(rx.cast(value).onSet, function(arg) {
        var n, o;
        o = arg[0], n = arg[1];
        if ((n == null) || _.isString(n)) {
          setProp(elt, 'style', n);
        } else {
          elt.removeAttr('style').css(n);
        }
        if (isCell && rxt.events.enabled) {
          return rxt.events.onElementAttrsChanged.pub({
            $element: elt,
            attr: "style"
          });
        }
      });
    };
    rxt.smushClasses = function(xs) {
      return _(xs).chain().flatten().compact().value().join(' ').replace(/\s+/, ' ').trim();
    };
    specialAttrs["class"] = function(elt, value) {
      return setDynProp(elt, 'class', value, function(val) {
        if (_.isString(val)) {
          return val;
        } else {
          return rxt.smushClasses(val);
        }
      });
    };
    rx.rxt = rxt;
    return rx;
  };

  (function(root, factory) {
    var $, _, deps, missing, rx;
    deps = ['bobtail-rx', 'jquery'];
    if ((typeof define !== "undefined" && define !== null ? define.amd : void 0) != null) {
      return define(deps, factory);
    } else if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
      rx = require('bobtail-rx');
      $ = require('jquery');
      _ = require('underscore');
      require('es5-shim');
      require('es6-shim');
      return module.exports = factory(rx, _, $);
    } else if ((root._ != null) && (root.$ != null) && root.rx) {
      return factory(root.rx, root._, root.$);
    } else {
      missing = [root.rx == null ? 'bobtail-rx' : void 0, root._ == null ? '_' : void 0, root.$ == null ? '$' : void 0].filter(function(x) {
        return x;
      });
      throw "Dependencies are not met for bobtail: " + (missing.join(',')) + " not found";
    }
  })(this, rxFactory);

}).call(this);

//# sourceMappingURL=main.js.map
