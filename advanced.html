<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="styles/9981d504.main.css" media="screen">
    <title>Tutorial - bobtail</title>
  </head>
  <body>
    <header>
      <div class="overlay"></div>
      <div class="inner">
        <h1 class="smaller-title"><a href="/reactive-coffee/">bobtail</a></h1>
        <nav class="top-nav">
          <div class="inner-inner"><a href="quickstart.html">Documentation</a><a href="support.html">Community/Support</a><a href="design.html">Rationale</a><a href="dev-setup.html">Development</a></div>
        </nav>
      </div>
    </header>
    <div id="content-wrapper">
      <div class="inner clearfix">
        <nav class="side-nav">
          <ul>
            <li><a href="quickstart.html">Quickstart Examples</a></li>
            <li><a href="tutorial.html">Tutorial</a></li>
            <li><a href="advanced.html" class="current">Advanced Concepts</a><ul class="toc"><li><a href="#side-effects-and-resource-cleanup">Side Effects and Resource Cleanup</a></li><li><a href="#garbage-collection">Garbage Collection</a></li><li><a href="#mutations-inside-binds">Mutations Inside Binds</a></li><li><a href="#asynchronous-binds">Asynchronous Binds</a></li><li><a href="#es5-properties">ES5 Properties</a></li></ul></li>
            <li><a href="api.html">API Reference</a></li>
            <li><a href="changes.html">Change Log</a></li>
          </ul>
        </nav>
        <section id="main-content"><h2 id="side-effects-and-resource-cleanup"><a name="side-effects-and-resource-cleanup">Side Effects and Resource Cleanup</a></h2>
<p>Sometimes you will have side effects associated with certain <code>bind</code>s or
components, such as establishing a connection or setting an interval timer:</p>
<div class="highlight"><pre><span class="nv">blinkingBox = </span><span class="nf">(opts) -&gt;</span>
  <span class="nv">active = </span> <span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span> <span class="kc">false</span>
  <span class="nx">setInterval</span> <span class="p">(</span><span class="nf">-&gt;</span> <span class="nx">active</span><span class="p">.</span><span class="nx">set</span> <span class="o">not</span> <span class="nx">active</span><span class="p">.</span><span class="nx">get</span><span class="p">()),</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">ms</span> <span class="o">?</span> <span class="mi">500</span>
  <span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="k">if</span> <span class="nx">active</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="k">then</span> <span class="s">&#39;red-box&#39;</span> <span class="k">else</span> <span class="s">&#39;black-box&#39;</span><span class="p">}</span>

<span class="nx">$</span><span class="p">(</span><span class="s">&#39;body&#39;</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span>
  <span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;container&#39;</span><span class="p">},</span> <span class="nx">boxes</span><span class="p">.</span><span class="nx">map</span> <span class="nf">-&gt;</span> <span class="nx">blinkingBox</span><span class="p">()</span>
<span class="p">)</span>
</pre></div>

<p>In these cases, you&#39;ll want to do proper resource management/cleanup
whenever the <code>bind</code> context is removed or refreshedâ€”in this case, stopping
the interval timer.  For these situations, you can use
<code>rx.onDispose(callback)</code>:</p>
<div class="highlight"><pre><span class="nv">blinkingBox = </span><span class="nf">(opts) -&gt;</span>
  <span class="nv">active = </span> <span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span> <span class="kc">false</span>
  <span class="nv">interval = </span><span class="nx">setInterval</span> <span class="p">(</span><span class="nf">-&gt;</span> <span class="nx">active</span><span class="p">.</span><span class="nx">set</span> <span class="o">not</span> <span class="nx">active</span><span class="p">.</span><span class="nx">get</span><span class="p">()),</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">ms</span> <span class="o">?</span> <span class="mi">500</span>
  <span class="nx">rx</span><span class="p">.</span><span class="nx">onDispose</span> <span class="nf">-&gt;</span> <span class="nx">clearInterval</span><span class="p">(</span><span class="nx">interval</span><span class="p">)</span>
  <span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="k">if</span> <span class="nx">active</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="k">then</span> <span class="s">&#39;red-box&#39;</span> <span class="k">else</span> <span class="s">&#39;black-box&#39;</span><span class="p">}</span>
</pre></div>

<h2 id="garbage-collection"><a name="garbage-collection">Garbage Collection</a></h2>
<p>Dependencies hold references to their dependents in order to know who to
propagate updates to.  We do currently unsubscribe a dependent observable
from its dependencies whenever that dependent is refreshed, but if the
dependent observable itself creates nested binds, those nested binds must
also be disconnected, and so on, recursively.</p>
<p>For instance, say we have:</p>
<div class="highlight"><pre><span class="nv">showUnread = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="nv">unread = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;scoreboard&#39;</span><span class="p">},</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="p">[</span>
  <span class="k">if</span> <span class="nx">showUnread</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
    <span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;unread&#39;</span><span class="p">},</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">unread</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span><span class="si">}</span><span class="s"> message(s)&quot;</span>
  <span class="k">else</span>
    <span class="s">&#39;(nothing shown)&#39;</span>
<span class="p">]</span>
</pre></div>

<p>Initially, <code>unread</code> has a subscriber, as expected: the inner <code>bind</code>.  When
we update <code>showUnread</code>, the outer <code>bind</code> will re-evaluate and create a new
inner <code>bind</code> (for the nested <code>div</code>), completely forgetting about the old
one.  Without the nested bind cleanup, <code>unread</code> now has <em>two</em> subscribers,
old and new inner <code>bind</code>s.  And since the old inner <code>bind</code> is still
referenced from <code>unread</code>&#39;s list of subscribers, it can&#39;t be
garbage-collected.  Ergo, memory leak.</p>
<p>What instead happens: <code>bind</code> tracks any nested <code>bind</code>s.  On re-evaluation,
these inner <code>bind</code>s are <em>disconnected</em>, unsubscribing themselves from all
their dependencies.  This disconnection also occurs recursively down to
<em>their</em> nested <code>bind</code>s, and so on.</p>
<p>One question is what happens at the top level or when you want to break out
and do your own thing. We don&#39;t have the luxury of weak refs in JS, and as
a result it&#39;s less forgiving if you do &quot;silly&quot; things like create binds
that go nowhere and that you don&#39;t want to keep.</p>
<p>(But even with weak references, one can&#39;t tell if you added a bind only to
subscribe a console.log caller to its changes, save to localStorage, or
some other side effect that you <em>do</em> want to keep.)</p>
<p>For instance, you don&#39;t want to write the above as the following:</p>
<div class="highlight"><pre><span class="nv">showing = </span><span class="kc">false</span>
<span class="nx">$</span><span class="p">(</span><span class="s">&#39;.toggle-button&#39;</span><span class="p">).</span><span class="nx">click</span> <span class="nf">-&gt;</span>
  <span class="k">if</span> <span class="nx">showing</span>
    <span class="nx">$</span><span class="p">(</span><span class="s">&#39;.scoreboard&#39;</span><span class="p">).</span><span class="nx">html</span><span class="p">(</span>
      <span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;unread&#39;</span><span class="p">},</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">unread</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span><span class="si">}</span><span class="s"> message(s)&quot;</span>
    <span class="p">)</span>
  <span class="k">else</span>
    <span class="nx">$</span><span class="p">(</span><span class="s">&#39;.scoreboard&#39;</span><span class="p">).</span><span class="nx">text</span><span class="p">(</span><span class="s">&#39;(nothing shown)&#39;</span><span class="p">)</span>
  <span class="nv">showing = </span><span class="o">not</span> <span class="nx">showing</span>
<span class="p">}</span>
</pre></div>

<p>The key for these situations is that <code>bind</code>s should go all the way to the
top, or else you&#39;ll want to manually disconnect your (top-level) binds
using their <code>disconnect</code> method:</p>
<div class="highlight"><pre><span class="nv">showing = </span><span class="kc">false</span>
<span class="nv">topBind = </span><span class="kc">null</span>
<span class="nx">$</span><span class="p">(</span><span class="s">&#39;.toggle-button&#39;</span><span class="p">).</span><span class="nx">click</span> <span class="nf">-&gt;</span>
  <span class="k">if</span> <span class="nx">showing</span>
    <span class="nx">$</span><span class="p">(</span><span class="s">&#39;.scoreboard&#39;</span><span class="p">).</span><span class="nx">html</span><span class="p">(</span>
      <span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;unread&#39;</span><span class="p">},</span> <span class="nv">topBind = </span><span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">unread</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span><span class="si">}</span><span class="s"> message(s)&quot;</span>
    <span class="p">)</span>
  <span class="k">else</span>
    <span class="nx">$</span><span class="p">(</span><span class="s">&#39;.scoreboard&#39;</span><span class="p">).</span><span class="nx">text</span><span class="p">(</span><span class="s">&#39;(nothing shown)&#39;</span><span class="p">)</span>
    <span class="nx">topBind</span><span class="p">.</span><span class="nx">disconnect</span><span class="p">()</span>
  <span class="nv">showing = </span><span class="o">not</span> <span class="nx">showing</span>
<span class="p">}</span>
</pre></div>

<h2 id="mutations-inside-binds"><a name="mutations-inside-binds">Mutations Inside Binds</a></h2>
<p>Say you had some dependent cell:</p>
<div class="highlight"><pre><span class="nv">plusOne = </span><span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">src</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>

<p>If you try something like the following, i.e. explicitly wire up a
dependent cell (plusOne, which depends on src) to modify another source cell (dst):</p>
<div class="highlight"><pre><span class="nv">dst = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">()</span>
<span class="nx">bind</span> <span class="nf">-&gt;</span>
  <span class="nv">x = </span><span class="nx">plusOne</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
  <span class="nx">dst</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="nx">src</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

<p>you&#39;ll get a warning that you&#39;re trying to perform a cell-mutating
operation within the subgraph of a dependent cell.</p>
<p>This is discouraged because a well-structured program should exhibit a
clean DAG of dependencies.  When you do something like this, you&#39;re
potentially creating cycles.  It also muddies what <code>dst</code> <em>should</em> reflect,
when you have multiple bind locations calling <code>dst.set(...)</code>â€”it&#39;s often
clearer to express the value of <code>dst</code> as some expression of its
dependencies.</p>
<p>Usually you&#39;ll instead want to have <code>dst</code> be a dependent cell of <code>plusOne</code>
rather than be its own <code>SrcCell</code>:</p>
<div class="highlight"><pre><span class="nv">dst = </span><span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">plusOne</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
</pre></div>

<p>However, in case you need an escape hatch in a bind (har har), you can
always set up a manual listener:</p>
<div class="highlight"><pre><span class="nv">plusOne = </span><span class="nx">bind</span> <span class="nf">-&gt;</span>
  <span class="nx">src</span><span class="p">.</span><span class="nx">onSet</span><span class="p">.</span><span class="nx">sub</span> <span class="nx">rx</span><span class="p">.</span><span class="nx">skipFirst</span> <span class="nf">([old, val]) -&gt;</span> <span class="nx">val</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">...</span>
</pre></div>

<p>We need <code>skipFirst</code> since by default the listener is immediately invoked
with the current value of <code>src</code>.</p>
<p>Note that <code>dst</code> will not be considered a dependency of <code>src</code> or <code>plusOne</code>.
This connection is unmanaged (or rather, managed by you).</p>
<p>So if this is happening within some bind context, you must also unsubscribe
on context disposal:</p>
<div class="highlight"><pre><span class="nv">uid = </span><span class="nx">src</span><span class="p">.</span><span class="nx">onSet</span><span class="p">.</span><span class="nx">sub</span> <span class="nx">rx</span><span class="p">.</span><span class="nx">skipFirst</span> <span class="nf">([old, val]) -&gt;</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
<span class="nx">rx</span><span class="p">.</span><span class="nx">onDispose</span> <span class="nf">-&gt;</span> <span class="nx">src</span><span class="p">.</span><span class="nx">onSet</span><span class="p">.</span><span class="nx">unsub</span><span class="p">(</span><span class="nx">uid</span><span class="p">)</span>
</pre></div>

<p>There is a convenience function, <code>autoSub</code>, which will take care of this
for you:</p>
<div class="highlight"><pre><span class="nx">rx</span><span class="p">.</span><span class="nx">autoSub</span> <span class="nx">src</span><span class="p">.</span><span class="nx">onSet</span><span class="p">,</span> <span class="nx">rx</span><span class="p">.</span><span class="nx">skipFirst</span> <span class="nf">([old, val]) -&gt;</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
</pre></div>

<h2 id="asynchronous-binds"><a name="asynchronous-binds">Asynchronous Binds</a></h2>
<p>So far we&#39;ve seen <em>synchronous</em> binds.  However, let&#39;s say you want to have
introduce a delay between when a bind&#39;s dependencies are updated and when
that bind is evaluated.  This can be useful, for instance, if you have an
expensive bind over some dependencies, where the dependencies can change in
bursts of high frequency, and you don&#39;t want the app to block on
re-evaluating the bind every time the dependencies change.  Similarly, you
may want a UI component to update in response to the user entering text
into a text box, but you don&#39;t want a jarring user experience and want to
instead only update the UI once the user stops typing for some time.</p>
<p>There is in fact a <code>lagBind</code>:</p>
<div class="highlight"><pre><span class="nv">y = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">lagBind</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">-&gt;</span> <span class="nx">expensiveFunction</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">get</span><span class="p">())</span>
</pre></div>

<p>Here, <code>y</code> isn&#39;t immediately evaluated every time <code>x</code> changes; rather, <code>y</code>
(which is initialized to 0) waits for <code>x</code> to settle down for at least half
a second before evaluating the expensive function of <code>x</code>.</p>
<p>There&#39;s also a similar function, <code>postLagBind</code>, contributed by
<a href="https://github.com/eizenberg">@eizenberg</a>, which instead introduces a lag but <em>after</em> the function
evaluation/re-capture (which is immediate upon any changes to
dependencies).  This allows you to specify a dynamic delay as part of the
result, where the delay duration comes from observables.  In this example,
the tootip appears instantly, but disappears only after a delay:</p>
<div class="highlight"><pre><span class="nv">showTooltip = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">postLagBind</span> <span class="kc">false</span><span class="p">,</span> <span class="nf">-&gt;</span>
  <span class="k">if</span> <span class="nx">focused</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="o">and</span> <span class="nx">showTooltips</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="k">then</span> <span class="nv">val: </span><span class="kc">true</span><span class="p">,</span> <span class="nv">ms: </span><span class="mi">0</span>
  <span class="k">else</span> <span class="nv">val: </span><span class="kc">false</span><span class="p">,</span> <span class="nv">ms: </span><span class="mi">300</span>
</pre></div>

<p>More generally, you can implement your own asynchronous binds.  <code>bind</code>,
<code>lagBind</code>, and <code>postLagBind</code> are all expressed in terms of <code>asyncBind</code>.
You supply a function that runs the asynchronous
lifecycle.  At a single point in the lifecycle, you can call
<code>this.record(f)</code>, passing it a function which will record and subscribe to
dependencies.  This can be called only once; otherwise things like disposal
of prior subscriptions gets very complex and multiple in-flight lifecycles
gets more complex (if you need multiple stages of bindings separated by
asynchronous gaps, you can use a chain of multiple asynchronous binds).
Upon completion, <code>this.done(x)</code> must be called with the result.</p>
<p>Here&#39;s an example that immediately evaluates/records its dependencies and
then feeds that to an AJAX call; upon completion, the result is passed into
<code>@done</code>.</p>
<div class="highlight"><pre><span class="nv">y = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">asyncBind</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">-&gt;</span>
  <span class="nv">input = </span><span class="nx">@record</span> <span class="nf">-&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
  <span class="nx">ajaxCall</span><span class="p">({</span><span class="nv">data: </span><span class="nx">input</span><span class="p">,</span> <span class="nv">done: </span><span class="nf">(output) =&gt;</span> <span class="nx">@done</span><span class="p">(</span><span class="nx">output</span><span class="p">)})</span>
</pre></div>

<p>Users interested in <code>asyncBind</code> are also encouraged to take a look at the
(very short) implementations of <code>bind</code>, <code>lagBind</code>, and <code>postLagBind</code>.</p>
<h2 id="es5-properties"><a name="es5-properties">ES5 Properties</a></h2>
<p>So far, everything is built on observable data structures, which are just
plain classes with explicit getter/setter calls.  To make working with
observables more natural/less verbose as well as more similar to working
with regular non-observable data structures, we can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">ES5 object
property getters/setters</a>, so that what used to be:</p>
<div class="highlight"><pre><span class="nv">card = </span><span class="nx">deck</span><span class="p">.</span><span class="nx">cards</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="nx">deck</span><span class="p">.</span><span class="nx">cards</span><span class="p">.</span><span class="nx">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="nx">card</span><span class="p">.</span><span class="nx">isFlipped</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="o">not</span> <span class="nx">card</span><span class="p">.</span><span class="nx">isFlipped</span><span class="p">.</span><span class="nx">get</span><span class="p">())</span>
</pre></div>

<p>becomes:</p>
<div class="highlight"><pre><span class="nv">card = </span><span class="nx">deck</span><span class="p">.</span><span class="nx">cards</span><span class="p">[</span><span class="nx">deck</span><span class="p">.</span><span class="nx">cards</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span class="nv">card.isFlipped = </span><span class="o">not</span> <span class="nx">card</span><span class="p">.</span><span class="nx">isFlipped</span>
</pre></div>

<p>Your class definitions are simpler as well.  You can rewrite this:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nx">Deck</span>
  <span class="nv">constructor: </span><span class="nf">(player, cards) -&gt;</span>
    <span class="vi">@player = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="nx">player</span><span class="p">)</span>
    <span class="vi">@cards = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">array</span><span class="p">(</span><span class="nx">cards</span><span class="p">)</span>
<span class="k">class</span> <span class="nx">Card</span>
  <span class="nv">constructor: </span><span class="nf">(suit, rank, isFlipped) -&gt;</span>
    <span class="vi">@suit = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="nx">suit</span><span class="p">)</span>
    <span class="vi">@rank = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="nx">rank</span><span class="p">)</span>
    <span class="vi">@isFlipped = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="nx">isFlipped</span><span class="p">)</span>
</pre></div>

<p>as:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nx">Deck</span>
  <span class="nv">constructor: </span><span class="nf">(@player, @cards) -&gt;</span>
    <span class="nx">rx</span><span class="p">.</span><span class="nx">autoReactify</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
<span class="k">class</span> <span class="nx">Card</span>
  <span class="nv">constructor: </span><span class="nf">(@suit, @rank, @isFlipped) -&gt;</span>
    <span class="nx">rx</span><span class="p">.</span><span class="nx">autoReactify</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
</pre></div>

<p>In short, you can construct &quot;plain&quot; objects, then <code>autoReactify</code> them, which
replaces all fields with ES5 getters/setters (coupled with hidden backing
observable cells/arrays).</p>
<p>However, there are a few caveats and limitations, primarily around arrays.
Arrays are implemented by actually replacing the methods on normal Arrays
with wrappers that also call the appropriate method on the observable.
However, there is no way to override the indexing/subscript operator <code>[]</code>
in JS.  As a result, normal indexing operations may be less efficient (this
will likely be fine for most arrays/binds in your application, however, unless
they&#39;re really big):</p>
<div class="highlight"><pre><span class="nx">deck</span><span class="p">.</span><span class="nx">player</span> <span class="c1"># translates into deck.player.get()</span>
<span class="nx">deck</span><span class="p">.</span><span class="nx">cards</span> <span class="c1"># translates into deck.cards.all()</span>
<span class="nx">deck</span><span class="p">.</span><span class="nx">cards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># translates into deck.cards.all()[0], not deck.cards.at(0)</span>
<span class="nx">deck</span><span class="p">.</span><span class="nx">cards</span><span class="p">.</span><span class="nx">length</span> <span class="c1"># translates into deck.cards.all().length</span>

<span class="c1"># so, these won&#39;t work react to changes</span>
<span class="nv">cards = </span><span class="nx">deck</span><span class="p">.</span><span class="nx">cards</span>
<span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">cards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">cards</span><span class="p">.</span><span class="nx">length</span>

<span class="c1"># instead, always access as a field:</span>
<span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">deck</span><span class="p">.</span><span class="nx">cards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="nx">deck</span><span class="p">.</span><span class="nx">cards</span><span class="p">.</span><span class="nx">length</span>
</pre></div>

<p>All things considered, we still recommend using normal observable arrays
over these magical ES5 array proxies, given the limitations.  When you call
<code>autoReactify</code> on an object, it will essentially ignore and leave intact
any existing observables.</p>
<p>Thanks to <a href="https://github.com/inferinc/bobtail/issues/6">@m1sta</a> for
bringing this idea to the table.</p>

        </section>
      </div>
    </div><!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41900480-1', 'yang.github.io');
      ga('send', 'pageview');
    </script>
    <footer>
      <div class="inner"><p>Copyright 2017 Bobtail/Reactive Coffee Authors.<br>Code licensed under <a href="https://github.com/inferinc/bobtail/blob/master/LICENSE">MIT License</a>.  Documentation licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.<br>Website design based on Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>

      </div>
    </footer>
  </body>
</html>
